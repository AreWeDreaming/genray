# genray_plots.py'
# Plots genray.nc (output data file produced by GENRAY)

# Yuri Petrov, Bob Harvey   CompX   2013

# Needed in working directory: genray.nc and eqdsk (if available)
# Rename your particular equilibrium-B file to eqdsk.

from numpy import *
from mpl_toolkits.mplot3d import Axes3D

from pylab import *
from matplotlib import rc 
from matplotlib.pyplot import cm,figure,axes,plot,xlabel,ylabel,title,savefig,show

import os
import math
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import time
import pylab as pylab
import scipy.io.netcdf as nc

#-----------------------------------------------
# NetCDF issues: machine-dependent
# Try netcdf=4 to envoke netCDF4,
# Or try netcdf=2 to work with older netCDF.
netcdf=4
#-----------------------------------------------
if netcdf==4: from netCDF4 import Dataset # YuP
#-----------------------------------------------


# Specify for plots:
fnt  = 12 #9   # Font size for axis numbers (see 'param=' below) 
linw = 1.  # LineWidth for contour plots
Ncont= 50  # Number of contour levels for PSI (pol.flux)
arr_len=5. # Specify arrow length for plots of (Nr,Nz) at start point (disabled)
nskip=1  # How many end-points to skip, for plotting (to avoid end-point jumps)


# Constants
pi=3.14159265358979
clight= 2.99792458e10   # speed of light [cm/s]
e     = 4.8032e-10      # e-charge [cgs]
e_mass= 9.10938291e-28  # e-mass   [gram]
p_mass= 1.67262158e-24  # proton mass    [gram]
ergtkev=1.6022e-09

# Make a guess about Min/Max of plasma; it will be found from eqdsk, if present
#Rmin= 50.
#Rmax= 300. # just any guess [cm] 
#Zmin=-200.
#Zmax= 200. # just any guess [cm] 



e0 = time.time()  # elapsed time since the epoch
c0 = time.clock() # total cpu time spent in the script so far


eqdsk_name='eqdskin'
#eqdsk_name='g1060728011.01100'



#==================================================================
def read_vector(flnm,ndim,nums_per_line):
    global nlines  #Can be used to return number of lines.
    """
    Reads delimited items from an open file, flnm.
    Returns them in a vector of input length ndim.
    nums_per_line is (assumed constant) number of
    items per line (except last line may be shorter).
    BH2009.
    """
    a=np.ones(ndim)
    nlines=ndim/nums_per_line
    if nlines*nums_per_line != ndim: nlines=nlines+1
    #print nlines
    for i in range(nlines):
        ibegin=i*nums_per_line
        iend=min(ibegin+nums_per_line,ndim)
        #print ibegin,iend
        a[ibegin:iend]=np.array(flnm.readline().split(),float)
    return a
#==================================================================

#******************************************************************
#******************************************************************
i_eqdsk=0  # it will be set to 1 if eqdsk is found
nlimiter=0 # it will be reset to other value, if data on limiter is avail. 
try:# Try reading eqdsk file, hoping it exists in the working directory.
    # Copy equilibrium B data file into working directory under name 'eqdsk'
    eqdsk=open(eqdsk_name,'r')
    lines=eqdsk.readlines()
    #fortran format 110  format(6a8,4i4), picking off 2nd and 3rd slots of 4i4.
    nr=lines[0][52:56]; nz=lines[0][56:60]
    nr=int(nr); nz=int(nz)
    try:
        nv=int(lines[0][60:64])
    except:   #line[60:64] not characters representing integers
        nv=nr
    #A difficulty making reading of eqdsk files difficult is that
    #when a number is procedded by a "-" sign, then there is no
    #blank space separating adjacent numbers.
    #For remaining lines after 1st down to possible occurance of
    #an "&", fortran format is format(5e16.9) [Except possible 
    #sequence of integers extending less that 1st 16 columns.
    #Therefore, Add blanks in columns 17,33,49,65, and use
    #above read_vector() function.

    #Determine line number of "&", if exists:
    #(lines[iamp] will be line before "&".)
    iamp=0
    for line in lines[1:]:
        if line.strip().find('&') == -1:
            iamp=iamp+1
        else:
            break

    #Introduce spaces in lines[1:iamp], skipping 1st and & lines.
    #This should be ok for standard eqdsks through reading xlimiter,ylimiter.
    #BH noticed a nonstandard format (i5,e16.9) further on.
    cols=range(16,65,16); cols.reverse()  #cols=[64, 48, 32, 16
    b=' '
    for i in range(1,iamp+1):
        for j in range(4):
            lines[i]=lines[i][0:cols[j]]+b+lines[i][cols[j]:]

    # Open tmp file, put adjusted lines in it, 
    # then read using previously constructed read_vector.
    tmp=open('./tmp','w')
    tmp.writelines(lines)
    tmp.close()
    tmp=open('./tmp','r')
    tmp.readline()  #space down one line
    #---
    rbox,zbox,radmaj,rboxdst,ymideqd=read_vector(tmp,5,5)
    raxis,zaxis,psimag,psilim,btor=read_vector(tmp,5,5)
    toteqd,psimx1,psimx2,xax1,xax2=read_vector(tmp,5,5)
    zax1,zax2,psisep,xsep,zsep=read_vector(tmp,5,5)
    fpsiar=read_vector(tmp,nv,5)
    prar=read_vector(tmp,nv,5)
    ffpar=read_vector(tmp,nv,5)
    ppar=read_vector(tmp,nv,5)
    epsi=read_vector(tmp,nr*nz,5)
    qar=read_vector(tmp,nv,5)
    ncontr, nlimiter=read_vector(tmp,2,2)
    ncontr=int(ncontr); nlimiter=int(nlimiter)
    #---
    # raxis,zaxis      are the major and vertical height of magnetic axis.
    # psimag,psilim    are the poloidal flux function values at the
    #                  magnetic axis and the last closed flux surface
    #                   (touching the limiter or the separatrix).
    # btor             is the vacuum toroidal magnetic field at radmaj.
    # toteqd           is the toroidal current.
    #
    # feqd(nnr),pres(nnr), usually, although dimension is
    #                      specified by nnv if it is present.
    # fpsiar = r * B_phi  at nnr equispaced points in psi
    #          from psimag to psilim.
    # prar   = are the pressure values at the same points.
    # ffpar  = fpsiar_prime, [i.e., d f/d (psi)] at the same points.
    # ppeqd  =  p_prime [i.e., d prar/d (psi)] at the same points.
    # epsi(nnr,nnz) are the psi values on the nnr * nnzprint 'nv=',nv
    #               equispaced grid.
    # qar(nnr)  gives safety factor q on the equispaced psi grid.
    #
    # The following quantities are given in some eqdsks, but are not
    # presently used in cql3d:
    # nlimit,nves  are the numbers of point at limiters and
    #              vacuum vessel wall.
    # rlimit(nlimit),zlimit(nlimit):
    # rlimit,zlimit      is the r,z location of the limiters wall.
    #       rves(nves),zves(nves):
    # rves,zves          is the r,z location of the limiters
    #                    vacuum vessel wall.
    if ncontr > 0:
        rzcontr=read_vector(tmp,2*ncontr,5)
        rzcontr.resize((ncontr,2))
        rcontr=rzcontr[:,0]
        zcontr=rzcontr[:,1]
    if nlimiter > 0:
        rzlimiter=read_vector(tmp,2*nlimiter,5)
        rzlimiter.resize((nlimiter,2))
        rlimiter=rzlimiter[:,0]
        zlimiter=rzlimiter[:,1]
    eqdsk.close()  # close 'eqdsk' file
    tmp.close()
    epsi.resize((nz,nr))
    i_eqdsk=1
    print '========================================'
    print 'nr=',nr
    print 'nz=',nz
    print 'nv=',nv
    print 'psimag=', psimag
    print 'psilim=', psilim
    print 'zaxis [m]=', zaxis
    print 'raxis [m]=', raxis
    print 'radmaj [m]=', radmaj
    print 'btor [Tesla]=',btor
    print 'fpsiar shape =', fpsiar.shape
    print 'epsi shape =', epsi.shape
    print 'nlimiter=',nlimiter
    print 'ncontr=',ncontr
    print 'read_eqdsk done'
    print '========================================'
    # convert to cgs:
    rbox=rbox*1.e+2 
    zbox=zbox*1.e+2
    rboxdst=rboxdst*1.e+2
    radmaj=radmaj*1.e+2
    toteqd=toteqd*3.e+9       
    R_axis  = raxis*1.e+2 # cgs
    Z_axis  = zaxis*1.e+2 # cgs
    fpsiar=fpsiar*1.e+6   # r * B_phi  [cgs now]
    epsi=  epsi*1.e+8     # cgs now
    psilim= psilim*1.e8  
    psimag= psimag*1.e8  
    btor=btor*1e4 # vacuum toroidal magnetic field at radmaj [Gauss]
    # Min/Max of plasma:
    Rmin= rboxdst
    Rmax= Rmin + rbox
    Zmin=(zaxis -zbox*.5) # in [cm]
    Zmax= Zmin + zbox     # in [cm]
    # Form R,Z grids
    dzz=zbox/(nz-1) # cgs
    drr=rbox/(nr-1) # cgs
    er=np.zeros(nr)
    ez=np.zeros(nz)
    er[0]=rboxdst    # cgs
    ez[0]= zaxis -zbox*.5
    for nn in range(1,nr,1):  # nn goes from 1 to nr-1
        er[nn]=er[nn-1]+drr   # R-grid [cm] 
    for nn in range(1,nz,1):  # nn goes from 1 to nz-1
        ez[nn]=ez[nn-1]+dzz   # Z-grid [cm]
    R,Z = np.meshgrid(er,ez) # 2D grids [cm]    
    #........................................................
    # Form the equally spaced psi array/grid.
    # psimag < psilim;  epsi has min. at m.axis
    delpsi= (psilim-psimag)/(nv-1)  
    psiar=np.zeros(nv)
    for ix in range(0,nv,1):  # ix goes from 0 to nv-1
        psiar[ix]= psimag + ix*delpsi # [psimag; psilim]
    #.........................................................
    # Grad(psi) components:
    grpsi_r, grpsi_z = np.gradient(epsi,dzz,drr)
    grpsi= sqrt(grpsi_r*grpsi_r + grpsi_z*grpsi_z)
    Bpol= zeros((nz,nr))
    Btor= zeros((nz,nr))
    Bpmn=1.e10 # will be found below
    Bpmx=0.    # will be found below
    # Define |Bpol|  and  Btor  [Gauss]
    for ir in range(0,nr,1):  # ir goes from 0 to nr-1
        for iz in range(0,nz,1):  # iz goes from 0 to nz-1
            Bpol[iz,ir]= grpsi[iz,ir]/er[ir]
            if psilim>psimag:
                if epsi[iz,ir]<psilim:
                    iv= int((epsi[iz,ir]-psimag)/delpsi)
                    #if iz==64: print epsi[iz,ir], iv, psiar[iv],psiar[iv+1]
                    Btor[iz,ir]=fpsiar[iv]/er[ir]
                    Bpmn=min(Bpol[iz,ir],Bpmn)
                    Bpmx=max(Bpol[iz,ir],Bpmx)
                else:
                    Btor[iz,ir]=btor*radmaj/er[ir]
            else: # psilim<psimag
                if epsi[iz,ir]>psilim:
                    iv= int((epsi[iz,ir]-psimag)/delpsi)
                    #if iz==64: print epsi[iz,ir], iv, psiar[iv],psiar[iv+1]
                    Btor[iz,ir]=fpsiar[iv]/er[ir]
                    Bpmn=min(Bpol[iz,ir],Bpmn)
                    Bpmx=max(Bpol[iz,ir],Bpmx)
                else:
                    Btor[iz,ir]=btor*radmaj/er[ir]            
    B=sqrt(Btor*Btor + Bpol*Bpol) # Total B as a function of (ir,iz)
    #print"shape(B)=" , shape(B)
except:
    print"i_eqdsk=",i_eqdsk    
    
if i_eqdsk==0: # eqdsk file is not readable
    nlimiter=0
    ncontr=0
    print"==========================================================="
    print"eqdsk file is not in the working directory or not readable."
    print"==========================================================="

#******************************************************************
#******************************************************************




#==================================================================
# Open the genray netcdf file, read only:

filenm='genray.nc'    # This is the file generated by GENRAY 


#Input netcdf file into a structure:
if netcdf==2: 
    dat=nc.netcdf_file(filenm,'r')
 
#------------YuP:
if netcdf==4: 
    dat= Dataset(filenm, 'r', format='NETCDF4')

print dat.file_format # print which format was used for the genray.nc file



print 'The genray file, ',filenm,', contains:'
print '========================================'
print "The global attributes: ",dat.dimensions.keys()        
print "File contains variables: ",dat.variables.keys()
print '========================================'

# The name of eqdsk file used for equilibrium B-field:
eqdskin=dat.variables['eqdskin']
print "eqdskin=",eqdskin[:]

n_eqdsk=0 # initialize
if i_eqdsk==0: # no data was read from eqdsk 
    # some eqdsk data:
    # Note: this data did not exist in early genray.nc:
    try:
        try:
            eqdsk_r=dat.variables['eqdsk_r']
        except:
            print('No data on eqdsk in genray.nc')
            n_eqdsk=0
        else:
            n_eqdsk=1
            eqdsk_r=dat.variables['eqdsk_r']
            print 'eqdsk_r is: ', eqdsk_r.long_name, eqdsk_r.shape
            eqdsk_z=dat.variables['eqdsk_z']
            print 'eqdsk_z is: ', eqdsk_z.long_name, eqdsk_z.shape
            eqdsk_psi=dat.variables['eqdsk_psi']
            print 'eqdsk_psi is: ', eqdsk_psi.long_name, eqdsk_psi.shape
    finally:
        print '----------------------------------------'


n_wall=0 # initialize
if nlimiter>0:
    # Note: r_wall array may not exist in genray.nc:
    try:
        try:
            r_wall=dat.variables['r_wall']
        except:
            print('No data on r_wall, z_wall in genray.nc')
            n_wall=0
        else:
            r_wall=dat.variables['r_wall']
            z_wall=dat.variables['z_wall']
            n_wall=r_wall.shape[0]
            print 'r_wall is: ', r_wall.long_name, r_wall.shape
            print 'z_wall is: ', z_wall.long_name, z_wall.shape  
            print 'n_wall=',n_wall
    finally:
        print '----------------------------------------'
    
    
# Note: powden_cl array did not exist in early genray.nc:
try:
    try:
        powden_cl=dat.variables['powden_cl']
    except:
        print('No data on powden_cl in genray.nc')
        n_powden_cl=0
    else:
        n_powden_cl=1
        powden_cl=dat.variables['powden_cl']
        print 'powden_cl is: ',powden_cl.units,powden_cl.shape
finally:
    print '----------------------------------------'


# Define min/max for major radius range:
if n_wall==0:  # wall is not defined; get limits from eqdsk:
    if n_eqdsk==1:
        Rmax=np.amax(eqdsk_r)*100
        Rmin=np.amin(eqdsk_r)*100 # meters -> cm
        Zmax=np.amax(eqdsk_z)*100
        Zmin=np.amin(eqdsk_z)*100 # meters -> cm
    else: 
        Rmin= 50.
        Rmax= 300. # just any guess [cm] 
        Zmin=-200.
        Zmax= 200. # just any guess [cm] 
else:
    Rmax=np.amax(r_wall)*100
    Rmin=np.amin(r_wall)*100
    Zmax=np.amax(z_wall)*100
    Zmin=np.amin(z_wall)*100


if n_wall > 0:  # data on wall is present
    Rmax=np.amax(r_wall)*100
    Rmin=np.amin(r_wall)*100
    Zmax=np.amax(z_wall)*100
    Zmin=np.amin(z_wall)*100
if ncontr > 0:  # data on LCFS is present
    R_LCFS_max=np.amax(rcontr)*100
    R_LCFS_min=np.amin(rcontr)*100
    Z_LCFS_max=np.amax(zcontr)*100
    Z_LCFS_min=np.amin(zcontr)*100
if nlimiter >0: # data on limiter is present
    Rmax=np.amax(rlimiter)*100
    Rmin=np.amin(rlimiter)*100
    Zmax=np.amax(zlimiter)*100
    Zmin=np.amin(zlimiter)*100
print 'Rmin,Rmax=', Rmin,Rmax
print 'Zmin,Zmax=', Zmin,Zmax  
print '----------------------------------------'



freqcy=dat.variables['freqcy']
#BH  print 'freqcy =',freqcy.long_name, freqcy[:], freqcy.units
print 'freqcy =',freqcy.long_name, freqcy.getValue(), freqcy.units
#BH f=freqcy[0]
f=freqcy.getValue()

mass=dat.variables['dmas']
print 'mass=', mass.long_name, mass[:], mass.units

charge=dat.variables['charge']
print 'charge=', charge.long_name, charge[:], charge.units

rho_bin_center=dat.variables['rho_bin_center']
print 'rho_bin_center is: ', rho_bin_center.long_name, rho_bin_center.shape

rho_bin=dat.variables['rho_bin']
print 'rho_bin is: ', rho_bin.long_name, rho_bin.shape

densprof=dat.variables['densprof']
print 'densprof is: ', densprof.long_name, densprof.shape

temprof=dat.variables['temprof']
print 'temprof is: ', temprof.long_name, temprof.shape

Nsp=temprof[:,0].size  # number of species
print 'Number of species: Nsp=',Nsp



# Averaged current densities
s_cur_den_parallel=dat.variables['s_cur_den_parallel']
print 's_cur_den_parallel is: ', s_cur_den_parallel.long_name, s_cur_den_parallel.shape
s_cur_den_onetwo=dat.variables['s_cur_den_onetwo']
print 's_cur_den_onetwo is: ', s_cur_den_onetwo.long_name, s_cur_den_onetwo.shape
s_cur_den_toroidal=dat.variables['s_cur_den_toroidal']
print 's_cur_den_toroidal is: ', s_cur_den_toroidal.long_name, s_cur_den_toroidal.shape
s_cur_den_poloidal=dat.variables['s_cur_den_poloidal']
print 's_cur_den_poloidal is: ', s_cur_den_poloidal.long_name, s_cur_den_poloidal.shape

# Power profiles [erg/sec/cm^3]
powden=dat.variables['powden']
print 'powden is: ',  powden.units, powden.shape
powden_e=dat.variables['powden_e']
print 'powden_e is: ', powden_e.units,powden_e.shape
powden_i=dat.variables['powden_i']
print 'powden_i is: ', powden_i.units, powden_i.shape

# For iabsorp.eq.3 only:
#powden_s=dat.variables['powden_s']
#print 'powden_s is: ', powden_s.long_name, powden_s.shape

# Total power [erg/sec]
power_total=dat.variables['power_total']
print 'power_total is: ', power_total.long_name, power_total.shape
power_inj_total=dat.variables['power_inj_total']
print 'power_inj_total is: ', power_inj_total.long_name, power_inj_total.shape
powtot_e=dat.variables['powtot_e']
print 'powtot_e is: ', powtot_e.long_name, powtot_e.shape
powtot_i=dat.variables['powtot_i']
print 'powtot_i is: ', powtot_i.long_name, powtot_i.shape
powtot_cl=dat.variables['powtot_cl']
print 'powtot_cl is: ', powtot_cl.long_name, powtot_cl.shape
# For iabsorp.eq.3 only:
#powtot_s=dat.variables['powtot_s']
#print 'powtot_s is: ', powtot_s.long_name, powtot_s.shape

ws=dat.variables['ws']
print 'ws is: ', ws.long_name, ws.shape

delpwr=dat.variables['delpwr']
print 'delpwr is: ', delpwr.long_name, delpwr.shape


# RAY trajectories
wr=dat.variables['wr']
print 'wr is: ', wr.long_name, wr.shape
wz=dat.variables['wz']
print 'wz is: ', wz.long_name, wz.shape
wphi=dat.variables['wphi']
print 'wphi is: ', wphi.long_name, wphi.shape
# Number of elements for each ray:
nrayelt=dat.variables['nrayelt']
print 'nrayelt is: ', nrayelt.long_name, nrayelt.shape
# Refractive indices along rays:
wnper=dat.variables['wnper']
print 'wnper is: ', wnper.long_name, wnper.shape
wnpar=dat.variables['wnpar']
print 'wnpar is: ', wnpar.long_name, wnpar.shape
wn_r=dat.variables['wn_r']
print 'wn_r is: ', wn_r.long_name, wn_r.shape
wn_z=dat.variables['wn_z']
print 'wn_z is: ', wn_z.long_name, wn_z.shape
wn_phi=dat.variables['wn_phi']
print 'wn_phi is: ', wn_phi.long_name, wn_phi.shape
# E-wave-field along rays
cwexde=dat.variables['cwexde']
print 'cwexde is: ', cwexde.long_name, cwexde.shape
cweyde=dat.variables['cweyde']
print 'cweyde is: ', cweyde.long_name, cweyde.shape
cwezde=dat.variables['cwezde']
print 'cwezde is: ', cwezde.long_name, cwezde.shape
# fluxn = Power Flux along rays:
fluxn=dat.variables['fluxn']
print 'fluxn is: ', fluxn.long_name, fluxn.shape, fluxn.units
# Total magnetic field along rays:
sbtot=dat.variables['sbtot']
print 'sbtot is: ',sbtot.long_name, sbtot.shape, sbtot.units
# density along rays [1/cm^3]
sene=dat.variables['sene']
print 'sene is: ', sene.long_name, sene.shape, sene.units
# Ki along rays
salphal=dat.variables['salphal']
print 'salphal is: ', salphal.long_name, salphal.shape

# Vgroup normalized to c:
vgr_z=dat.variables['vgr_z']
print 'vgr_z is: ', vgr_z.long_name, vgr_z.shape
vgr_r=dat.variables['vgr_r']
print 'vgr_r is: ', vgr_r.long_name, vgr_r.shape
vgr_phi=dat.variables['vgr_phi']
print 'vgr_phi is: ', vgr_phi.long_name, vgr_phi.shape

# Number of rays
Nrays=wz[:,0].size  
print 'Number of rays: Nrays=',Nrays
    
print '----------------------------------------'
#BH print power_inj_total.long_name, power_inj_total[0], power_inj_total.units
#BH print power_total.long_name, power_total[0], power_total.units
#BH print powtot_e.long_name,  powtot_e[0],  powtot_e.units
#BH print powtot_i.long_name,  powtot_i[0],  powtot_i.units
#BH print powtot_cl.long_name, powtot_cl[0], powtot_cl.units
print power_inj_total.long_name, power_inj_total.getValue(), power_inj_total.units
print power_total.long_name, power_total.getValue(), power_total.units
print powtot_e.long_name,  powtot_e.getValue(),  powtot_e.units
print powtot_i.long_name,  powtot_i.getValue(),  powtot_i.units
print powtot_cl.long_name, powtot_cl.getValue(), powtot_cl.units
print '----------------------------------------'

# Convert erg/sec to kW
power_total=     np.asscalar(power_total[:])/1.e10    
power_inj_total= np.asscalar(power_inj_total[:])/1.e10
powtot_e=        np.asscalar(powtot_e[:])/1.e10
powtot_i=        np.asscalar(powtot_i[:])/1.e10
powtot_cl=       np.asscalar(powtot_cl[:])/1.e10


#===================  PLOTS =============================================
#set fonts and line thicknesses
params = {
    'axes.linewidth': linw,
    'lines.linewidth': linw,
    'axes.labelsize': fnt+4,
    'text.fontsize': fnt+4,
    'legend.fontsize': fnt,
    'xtick.labelsize':fnt,
    'ytick.labelsize':fnt,
    'xtick.linewidth':linw,
    'ytick.linewidth':linw,
    'font.weight'  : 'regular',
    'format':'%.1e'
}
pylab.rcParams.update(params)
#rc.defaults() #to restore defaults

mpl.rcParams['font.size']=fnt+2  # set font size for text in mesh-plots



#----------------------------------------------------------------T(rho), n(rho)
fig0=plt.figure()
# Plot with different thickness of lines, depending on species number
linw_mx= 4*linw # largest thickness
linw_mn= 0.5    # smallest
if Nsp>1:
    dlinw= (linw_mx-linw_mn)/(Nsp-1)
else:
    dlinw=0
plt.subplot(221)
plt.hold(True)
#plt.title('$ T_e, T_i $')
#plt.xlabel(r'$\rho$')
plt.ylabel('$ T $   $ (keV) $',fontsize=fnt+4)
plt.grid(True)
for i in range(0,Nsp,1):
    if remainder(i,4)==0: col='k'
    if remainder(i,4)==1: col='b'
    if remainder(i,4)==2: col='r'
    if remainder(i,4)==3: col='g'    
    plt.plot(rho_bin[:],temprof[i,:],color=col,linewidth=linw_mx-i*dlinw)

plt.subplot(223) #-------------------------
dx=0.7/Nsp
for i in range(0,Nsp,1):
    if remainder(i,4)==0: col='k'
    if remainder(i,4)==1: col='b'
    if remainder(i,4)==2: col='r'
    if remainder(i,4)==3: col='g'  
    txt1=r"$m/m_e =$"+r"$%1.0f$" %(mass[i])
    txt2=r"$q/e =$"+r"$%1.0f$" %(charge[i])
    txt3=r"$T_0[keV] =$"+r"$%1.3f$" %(temprof[i,0])
    txt4=r"$n_0[10^{14}cm^{-3}] =$"+r"$%1.3f$" %(densprof[i,0]/1e14)
    plt.plot(0.05, 0.7-dx*i, 'o', color=col)
    plt.text(0.08, 0.7-dx*i, txt1 , va='center',fontsize=fnt+4)
    plt.text(0.65, 0.7-dx*i, txt2 , va='center',fontsize=fnt+4) 
    plt.text(0.95, 0.7-dx*i, txt3 , va='center',fontsize=fnt+4) 
    plt.text(1.55, 0.7-dx*i, txt4 , va='center',fontsize=fnt+4) 
    plt.axis([0., 1., 0., 1.])
    plt.axis('off')

plt.subplot(222)
plt.hold(True)
#plt.title('$ n_e, n_i $')
plt.xlabel(r'$\rho$',fontsize=fnt+4)
plt.ylabel('$ n $   $ (cm^{-3}) $',fontsize=fnt+4)
plt.grid(True)
for i in range(0,Nsp,1):
    if remainder(i,4)==0: col='k'
    if remainder(i,4)==1: col='b'
    if remainder(i,4)==2: col='r'
    if remainder(i,4)==3: col='g'    
    plt.plot(rho_bin[:],densprof[i,:],color=col,linewidth=linw_mx-i*dlinw)   

savefig('genray_profiles_T-n.png',format='png') # try pdf,eps,ps
show() 
#stop



#--------------------------------------------------------------------------
fig4=plt.figure()  # RAYS in top-view (R-phi or X-Y)
#ax = plt.subplot(1, 1, 1)
#ax.set_aspect(1.0)
plt.hold(True)
#plt.grid(True)
plt.title('$Rays$  $X(t),Y(t)$')
plt.xlabel('$X$  $(cm)$')
plt.ylabel('$Y$  $(cm)$')

# Define boundary for top-view (R-phi) plots:
phi=arange(301.)*2*pi/300.  # tor.angle in rad.
bndry_in_X= Rmin*cos(phi)
bndry_in_Y= Rmin*sin(phi)
bndry_out_X= Rmax*cos(phi)
bndry_out_Y= Rmax*sin(phi)

for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    print i,Nm
    if Nm>0:
        X=multiply(cos(wphi[i,0:Nm]),wr[i,0:Nm])
        Y=multiply(sin(wphi[i,0:Nm]),wr[i,0:Nm])
        plt.plot(X,Y,color=col,linewidth=linw)  
        # plot arrow for refractive vector (Nr,Nz) at starting point: 
        #Nr0=wn_r[i,0]
        #Ny0=wn_y[i,0]
        #N0=sqrt(Nr0*Nr0+Ny0*Ny0)
        #plt.arrow(wr[i,0],wy[i,0],(Nr0/N0)*arr_len,(Ny0/N0)*arr_len,'->') 
        plt.plot(X[0],Y[0],'ko') # small circle at launching point
plt.plot(bndry_in_X,  bndry_in_Y,  'b',linewidth=linw*2)
plt.plot(bndry_out_X, bndry_out_Y, 'b',linewidth=linw*2)
if nlimiter>0:
    plt.plot(R_LCFS_min*cos(phi), R_LCFS_min*sin(phi), 'g',linewidth=linw*2)
    plt.plot(R_LCFS_max*cos(phi), R_LCFS_max*sin(phi), 'g',linewidth=linw*2)
plt.axis('equal')  
plt.axis('off')
plt.savefig('genray_rays_in_R-phi.png') 
show()
#stop


#--------------------------------------------------------------------------
fig0=plt.figure() # RAYS in cross-sectional view R-Z
ax = plt.subplot(111)
ax.set_aspect(1.0)
plt.hold(True)
xmin=Rmin*0.99  # Limits for plots
xmax=Rmax*1.01  # 
zmin=Zmin*1.01  # Limits for plots
zmax=Zmax*1.01  # 
ax.axis([xmin,xmax,zmin,zmax])
plt.title('$Rays$  $R(t),Z(t)$')
plt.xlabel('$R$  $(cm)$')
plt.ylabel('$Z$  $(cm)$')
plt.grid(True)
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    #print i,Nm
    if Nm>0:
        plt.plot(wr[i,0:Nm],wz[i,0:Nm],color=col,linewidth=linw)
        # plot arrow for refractive vector (Nr,Nz) at starting point: 
        #Nr0=wn_r[i,0]
        #Nz0=wn_z[i,0]
        #N0=sqrt(Nr0*Nr0+Nz0*Nz0)
        #plt.arrow(wr[i,0],wz[i,0],(Nr0/N0)*arr_len,(Nz0/N0)*arr_len,'->') 
        # plot small circle at the launching point:
        plt.plot(wr[i,0],wz[i,0],'ko')
        print i+1, ' R0=',wr[i,0],  '   Z0=',wz[i,0]
if R_axis>0: plot(R_axis,Z_axis,'k+') # plot '+' at magnetic axis
if n_wall > 0:  # plot walls, if any:
    plt.plot(multiply(r_wall,100),multiply(z_wall,100),'b',linewidth=linw*2)
if ncontr > 0:  # plot LCFS, if any
    plt.plot(multiply(rcontr,100),multiply(zcontr,100),'g',linewidth=linw*2)
if (nlimiter>0 and n_wall==0): # plot limiter surface, if any
    plt.plot(multiply(rlimiter,100),multiply(zlimiter,100),'b',linewidth=linw*2)
if n_wall+ncontr+nlimiter ==0: # no data on walls or LCFS; Try plotting PSI
    if n_eqdsk==1:
        R,Z = np.meshgrid(eqdsk_r, eqdsk_z)
        PSI = eqdsk_psi
        CS=plt.contour( R*100,Z*100,PSI,Ncont,linewidths=1,cmap=plt.cm.hot)
plt.savefig('genray_rays_inRZ.png') 
show()

#stop

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
fig3=plt.figure()  # w/wc resonances and Pol.Flux in cross-section view R-Z
ax = plt.subplot(1, 1, 1)
ax.set_aspect(1.0)
ax.axis([xmin,xmax,zmin,zmax])
plt.hold(True)
plt.xlabel('$R$  $(cm)$')
plt.ylabel('$Z$  $(cm)$')
plt.grid(True)
if n_eqdsk==1: # plot contour lines of poloidal_flux/2pi
    R,Z = np.meshgrid(eqdsk_r, eqdsk_z)
    PSI = eqdsk_psi
    CS=plt.contour( R*100,Z*100,PSI,Ncont,linewidths=1,cmap=plt.cm.hot)
    #CB=plt.colorbar(orientation='vertical', shrink=0.5, format='%.2e')
if i_eqdsk==1: # Plot resonance layers for electrons or ions
    # B(r,z) was defined from eqdsk data
    #print shape(B), shape(R), n_eqdsk
    WWce0= f/abs(28e5*btor)  # omega/omega_ce at mag.axis
    print 'omega/omega_ce at mag.axis :' , WWce0
    print 'Nsp=',Nsp
    if (Nsp==1 or WWce0>1.0):  # Plot res.layers for electrons
        isp=0  # electrons
        level0= ceil(WWce0)
    if Nsp>0:
        isp=1  # Plot res.layers for ions#1 if present
        qm=  charge[isp]/mass[isp]  # q/m     
        WWci0= f/abs(28e5*qm*btor)  # omega/omega_ci
        print 'isp=',isp
        print 'omega/omega_ci at mag.axis :' , WWci0
        level0= ceil(WWci0)
    qm=  charge[isp]/mass[isp]  # q/m     
    WWc= f/abs(28e5*qm*B)  # omega/omega_c
    level_mn= max(1,level0-50)
    level_mx= level_mn+100
    levels=np.arange(level_mn,level_mx,1)
    CS=plt.contour(R,Z,WWc,levels,linewidths=linw,cmap=plt.cm.jet)
    plt.clabel(CS,inline=1, fmt='%1.0f',fontsize=fnt+1, colors='k',rightside_up=False)
    #CB=plt.colorbar(orientation='vertical', shrink=0.4,format='%.2f') #colorbar
    plot(R_axis,Z_axis,'k+') # plot '+' at magnetic axis
    txt1= r"  $m/m_e=$"+r"$%1.0f$" %(mass[isp])
    txt2= r"  $q/e=$"+r"$%1.0f$" %(charge[isp])
    plt.title('$\omega / \omega_{c}$'+'  $for$'+txt1+txt2)
if n_wall > 0:  # plot walls, if any:
    plt.plot(multiply(r_wall,100),multiply(z_wall,100),'k',linewidth=linw*2)
if ncontr > 0:  # plot LCFS, if any
    plt.plot(multiply(rcontr,100),multiply(zcontr,100),'g',linewidth=linw*2)
if nlimiter >0: # plot limiter surface, if any
    plt.plot(multiply(rlimiter,100),multiply(zlimiter,100),'b',linewidth=linw*2)
plt.savefig('genray_wwc_inRZ.png') 
show()
#stop


#--------------------------------------------------------------------------
fig8=plt.figure()  # E-wave-field along RAYS vs pol.distance(t)
plt.subplot(231) #-------------------------
plt.hold(True)
plt.title('$|E_X/E|$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        ereal=cwexde[0,i,0:Nm].copy()
        eimag=cwexde[1,i,0:Nm].copy()
        ea= sqrt(ereal**2 + eimag**2)
        plt.plot(ws[i,0:Nm],ea[0:Nm],color=col,linewidth=linw)  
plt.subplot(232) #-------------------------
plt.hold(True)
plt.title('$|E_Y/E|$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        ereal=cweyde[0,i,0:Nm].copy()
        eimag=cweyde[1,i,0:Nm].copy()
        ea= sqrt(ereal**2 + eimag**2)
        plt.plot(ws[i,0:Nm],ea[0:Nm],color=col,linewidth=linw)  
plt.subplot(233) #-------------------------
plt.hold(True)
plt.title('$|E_Z/E|$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        ereal=cwezde[0,i,0:Nm].copy()
        eimag=cwezde[1,i,0:Nm].copy()
        ea= sqrt(ereal**2 + eimag**2)
        plt.plot(ws[i,0:Nm],ea[0:Nm],color=col,linewidth=linw)
plt.subplot(234) #-------------------------
plt.hold(True)
plt.ylabel('$Power$ $Flux$ $(erg/s/cm^2)$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],fluxn[i,0:Nm],color=col,linewidth=linw)
plt.xlabel('$poloidal$ $distance$ $along$ $ray$  $(cm)$')
plt.subplot(236) #-------------------------
plt.hold(True)
plt.ylabel('$Lin.Damping$ $k_i$ $(cm^{-1})$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],salphal[i,0:Nm],color=col,linewidth=linw)
plt.xlabel('$poloidal$ $distance$ $along$ $ray$  $(cm)$')
plt.savefig('genray_rays_Ewave_p.png') 
show()


#--------------------------------------------------------------------------
fig81=plt.figure()  # Vgroup/c along RAYS vs pol.distance(t)
plt.subplot(231) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$V_{grp,R}/c$  $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],vgr_r[i,0:Nm],color=col,linewidth=linw)  
plt.subplot(232) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$V_{grp,\phi}/c$  $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],vgr_phi[i,0:Nm],color=col,linewidth=linw)  
plt.subplot(233) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$V_{grp,Z}/c$  $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],vgr_z[i,0:Nm],color=col,linewidth=linw)
plt.subplot(235) #-------------------------
plt.hold(True)
plt.grid(True)
plt.ylabel('$|V_{grp}/c|$  $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        vgrr=vgr_r[i,0:Nm]
        vgrphi=vgr_phi[i,0:Nm]
        vgrz=vgr_z[i,0:Nm]
        vgr=sqrt(vgrr**2+vgrphi**2+vgrz**2)
        plt.plot(ws[i,0:Nm],vgr[0:Nm],color=col,linewidth=linw)
plt.xlabel('$poloidal$ $distance$ $along$ $ray$  $(cm)$')
plt.savefig('genray_rays_Vgroup_p.png') 
show()



#--------------------------------------------------------------------------
fig5=plt.figure()  # wce/w and (wpe/w)^2 along RAYS vs distance
qm=  charge[0]/mass[0]  # First species is electrons
q2m= charge[0]**2/mass[0]
plt.subplot(231) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$|\omega_{ce}/\omega|$  $along$ $rays$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],abs(28e5*qm*sbtot[i,0:Nm]/f),color=col,linewidth=linw)
#plt.xlabel('$poloidal$ $distance$ $along$ $ray$  $(cm)$')

plt.subplot(232) #------------------------- value of RF frequency
txt=r"$f (MHz) =$"+r"$%1.3f$" %(f*1e-6)
plt.title(txt)   # 
plt.axis('off')

plt.subplot(233) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$(\omega_{pe}/\omega)^2$  $along$ $rays$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        #print 806.2e5*sene[0,0]*q2m/f**2, sene[0,0], q2m
        plt.plot(ws[i,0:Nm],806.2e5*sene[i,0:Nm]*q2m/f**2,color=col,linewidth=linw)    
plt.xlabel('$pol.distance$ $along$ $ray$  $(cm)$')

if Nsp>1: # plot w_ci/w along rays
    plt.subplot(235) #-------------------------
    plt.hold(True)
    plt.grid(True)
    isp=1  # First ion species
    qm=  charge[isp]/mass[isp]  # First ion species
    for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
        if remainder(i,6)==0: col='b'
        if remainder(i,6)==1: col='g'
        if remainder(i,6)==2: col='r'
        if remainder(i,6)==3: col='c'    
        if remainder(i,6)==4: col='m' 
        if remainder(i,6)==5: col='k'  
        Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
        if Nm>0:
            plt.plot(ws[i,0:Nm],abs(28e5*qm*sbtot[i,0:Nm]/f),color=col,linewidth=linw)
    plt.xlabel('$pol.distance$ $along$ $ray$  $(cm)$')
    txt1=r"  $m/m_e=$"+r"$%1.0f$" %(mass[isp])
    txt2=r"  $q/e=$"+r"$%1.0f$" %(charge[isp])
    plt.ylabel('$For:$'+txt1+txt2)
    plt.title('$|\omega_{ci}/\omega|$')
plt.savefig('genray_rays_wc_wp_p.png') 
show()



#--------------------------------------------------------------------------
fig5=plt.figure()  # Refractive indices along RAYS vs R(t)
ax=plt.subplot(231) #-------------------------
plt.hold(True)
plt.title('$n_R$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(wr[i,0:Nm-1],wn_r[i,0:Nm-1],color=col,linewidth=linw)  
plt.subplot(232) #-------------------------
plt.hold(True)
plt.title('$n_Z$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(wr[i,0:Nm],wn_z[i,0:Nm],color=col,linewidth=linw)  
plt.subplot(233) #-------------------------
plt.hold(True)
plt.title(r'$n_\phi$'+' $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(wr[i,0:Nm],wn_phi[i,0:Nm],color=col,linewidth=linw)
plt.subplot(234) #-------------------------
plt.hold(True)
plt.ylabel(r'$n_{\perp}$'+' $along$ $ray$')
plt.xlabel('$R$ $along$ $ray$  $(cm)$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(wr[i,0:Nm],wnper[i,0:Nm],color=col,linewidth=linw)
plt.subplot(235) #-------------------------
plt.hold(True)
plt.title(r'$n_{||}$'+' $along$ $ray$',verticalalignment='center')
plt.xlabel('$R$ $along$ $ray$  $(cm)$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(wr[i,0:Nm],wnpar[i,0:Nm],color=col,linewidth=linw)
plt.subplot(236) #-------------------------
plt.hold(True)
plt.title('$Lin.Damping$ $k_i$ $(cm^{-1})$',verticalalignment='center')
plt.xlabel('$R$ $along$ $ray$  $(cm)$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(wr[i,0:Nm],salphal[i,0:Nm],color=col,linewidth=linw)
plt.savefig('genray_rays_refr-index_R.png') 
show()

#stop


#--------------------------------------------------------------------------
fig6=plt.figure()  # Refractive indices along RAYS vs pol.distance(t)
plt.subplot(231) #-------------------------
plt.hold(True)
plt.title('$n_R$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],wn_r[i,0:Nm],color=col,linewidth=linw)  
plt.subplot(232) #-------------------------
plt.hold(True)
plt.title('$n_Z$ $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],wn_z[i,0:Nm],color=col,linewidth=linw)  
plt.subplot(233) #-------------------------
plt.hold(True)
plt.title(r'$n_\phi$'+' $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],wn_phi[i,0:Nm],color=col,linewidth=linw)
plt.subplot(234) #-------------------------
plt.hold(True)
plt.ylabel(r'$n_{\perp}$'+' $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],wnper[i,0:Nm],color=col,linewidth=linw)
plt.subplot(235) #-------------------------
plt.hold(True)
plt.title(r'$n_{||}$'+' $along$ $ray$',verticalalignment='center')
plt.xlabel('$poloidal$ $distance$ $along$ $ray$  $(cm)$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],wnpar[i,0:Nm],color=col,linewidth=linw)
plt.subplot(236) #-------------------------
plt.hold(True)
plt.title(r'$|n|$'+' $along$ $ray$',verticalalignment='center')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i])-nskip # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],sqrt(wnpar[i,0:Nm]**2+wnper[i,0:Nm]**2),color=col,linewidth=linw)
plt.savefig('genray_rays_refr-index_p.png') 
show()


# Renormalize power to the value used in experiment:
pwrscale=1.0 #1.9 # multiplication factor for input power
# (powers p and currents j will be renormalized by pwrscale)
power_total= power_total*pwrscale
power_inj_total= power_inj_total*pwrscale
powtot_e= powtot_e*pwrscale
powtot_i= powtot_i*pwrscale
if n_powden_cl>0:
    powtot_cl= powtot_cl*pwrscale

powden_e= np.asarray(powden_e)*pwrscale
powden_i= np.asarray(powden_i)*pwrscale
if n_powden_cl>0:
    powden_cl=np.asarray(powden_cl)*pwrscale
powden=   np.asarray(powden)*pwrscale
s_cur_den_parallel=np.asarray(s_cur_den_parallel)*pwrscale
s_cur_den_onetwo=  np.asarray(s_cur_den_onetwo)*pwrscale
s_cur_den_toroidal=np.asarray(s_cur_den_toroidal)*pwrscale
s_cur_den_poloidal=np.asarray(s_cur_den_poloidal)*pwrscale
delpwr= np.asarray(delpwr)*pwrscale

# factor 1e-4 is to convert erg/s/cm^3 -> kW/m^3
powden=  np.asarray(powden)/1.0e4 # kW/m^3
powden_e=np.asarray(powden_e)/1.0e4 # kW/m^3
powden_i=np.asarray(powden_i)/1.0e4 # kW/m^3
if n_powden_cl>0:
    powden_cl=np.asarray(powden_cl)/1.0e4 # kW/m^3
rhomax=1.05*np.amax(rho_bin_center)

#--------------------------------------------------------------------------
fig7=plt.figure()   # Power profiles
plt.subplot(221) #-------------------------
title('$Power$ $den$  $(kW/m^3)$') 
plt.hold(True)
plt.grid(True)
plt.ylabel('$p_e$')
plt.plot(rho_bin_center,(powden_e),'r',linewidth=linw)
axis([0.,rhomax,0.,1.05*np.amax(powden_e)+1.e-2])

plt.subplot(222) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$p_i$ $(Maxw.$ $ions)$')
plt.plot(rho_bin_center,(powden_i),'b',linewidth=linw*2)
#plt.title('$p_i$ $(Maxw.$ $ions)$ $and$ $p_e$ $(black)$')
#plt.plot(rho_bin_center,np.asarray(powden_e)*1.e-7,'k',linewidth=linw)
axis([0.,rhomax,0.,1.05*np.amax(powden_i)+1.e-2])
#axis([0.,1., 0., 0.35])

plt.subplot(223) #-------------------------
plt.hold(True)
plt.grid(True)
plt.xlabel(r'$\rho$')
plt.ylabel('$Collisional$ $p_{cl}$')
if n_powden_cl>0:
    plt.plot(rho_bin_center,(powden_cl),'r',linewidth=linw)
    axis([0.,rhomax,0.,1.05*np.amax(powden_cl)+1.e-2])

plt.subplot(224) #-------------------------
plt.hold(True)
plt.grid(True)
plt.xlabel(r'$\rho$')
txt="$p_{total}$"+"$=$%3.3f" %(power_total) +" $kW$"
plt.title(txt,verticalalignment='center')
plt.plot(rho_bin_center,(powden),'r',linewidth=linw)
axis([0.,rhomax,0.,1.05*np.amax(powden)+1.e-2])

savefig('genray_profiles_power.png')
show() 




#--------------------------------------------------------------------------
fig1=plt.figure()   # Current profiles
plt.subplot(221) #-------------------------
title('$Current$ $Profiles$  $(A/cm^2)$')
plt.hold(True)
plt.grid(True)
plt.ylabel('$<j_{||}>$')
plt.plot(rho_bin_center,s_cur_den_parallel,'r',linewidth=linw)
plt.subplot(222) #-------------------------
plt.hold(True)
plt.grid(True)
plt.title('$<j.B>/B_0$')
plt.plot(rho_bin_center,s_cur_den_onetwo,'r',linewidth=linw)
plt.subplot(223) #-------------------------
plt.hold(True)
plt.grid(True)
plt.xlabel(r'$\rho$')
plt.title('$<j_{||}>RB<1/R^2>/(<B><1/R>)$',verticalalignment='center')
plt.plot(rho_bin_center,s_cur_den_toroidal,'r',linewidth=linw)
plt.subplot(224) #-------------------------
plt.hold(True)
plt.grid(True)
plt.xlabel(r'$\rho$')
plt.title('$<j_{||}>B_{pol}($'+r'$\theta$'+'$=0)/<B>$',verticalalignment='center')
plt.plot(rho_bin_center,s_cur_den_poloidal,'r',linewidth=linw)
savefig('genray_profiles_J.png')
show() 


fig2=plt.figure()

plt.subplot(211) #-------------------------
plt.hold(True)
plt.grid(True)
#plt.title(delpwr.long_name)
#plt.xlabel('$poloidal$ $distance$ $along$ $ray$  $ws$  $(cm)$')
plt.ylabel('$power$ $in$ $ray$ $(MW)$')
# Plot with different thickness of lines, depending on ray
linw_mx= 6*linw # largest thickness
linw_mn= 0.5    # smallest
if Nrays>1:
    dlinw= (linw_mx-linw_mn)/(Nrays-1)
else:
    dlinw=0
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= nrayelt[i] # max number of points along a ray
    if Nm>0:
        plt.plot(ws[i,0:Nm],delpwr[i,0:Nm]/1e13,linewidth=linw_mx-i*dlinw)

plt.subplot(212) #-------------------------
plt.hold(True)
plt.grid(True)
plt.ylabel('$(\omega_{pe}/\omega)^2$  $along$ $ray$')
for i in range(0,Nrays,1):  # i goes from 0 to Nrays-1
    if remainder(i,6)==0: col='b'
    if remainder(i,6)==1: col='g'
    if remainder(i,6)==2: col='r'
    if remainder(i,6)==3: col='c'    
    if remainder(i,6)==4: col='m' 
    if remainder(i,6)==5: col='k'  
    Nm= np.asscalar(nrayelt[i]) # max number of points along a ray
    if Nm>0:
        #print 806.2e5*sene[0,0]*q2m/f**2, sene[0,0], q2m
        plt.plot(ws[i,0:Nm],806.2e5*sene[i,0:Nm]*q2m/f**2,color=col,linewidth=linw_mx-i*dlinw)
    
plt.xlabel('$pol.distance$ $along$ $ray$  $(cm)$')
plt.savefig('genray_rays_delpwr.png') 
plt.savefig('genray_rays_delpwr.eps') 
show()





dat.close() # close genray.nc
         
elapsed_time = time.time() - e0
cpu_time = time.clock() - c0
print 'elapsed and cpu time since start (sec.) =', elapsed_time, cpu_time
print 'FINISHED'
