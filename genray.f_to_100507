
 
c        ********************* GENRAY ***********************
c        *                     ------                       *
c        * GENRAY is the computer code  for  obtaining  the *
c        * trajectories of different  wave  modes  by  ray- *
c        * tracing techniques                               *
c        *                                                  *
c        * Authors: Alexander P. Smirnov (primary)          *
c        *          Moscow State University                 *
c        *          (sap@ns.cnt.ru, sap@cs.msu.su)          *
c        *          R.W. Harvey          (secondary)        *
c        *          CompX                                   *
c        *          (bobh@compxco.com)                      *
c        *                                                  *
c        * Manual: GENRAY, Report CompX-01-2000 (2000)      *
c        *                 CompX, PO Box 2672, Del Mar, CA  * 
c        *                                                  *
c        ****************************************************
c
c-----------------------------------------------------------------!
c								  !
c           method of solution and coordinate system.		  !
c								  !
c        the wave trajectories are obtained from the solution     !
c        of  geometrical  optics  equations  where   independent  !
c        space variables are: 					  !
c								  !
c           z, r, phi - cylindrical coordinates			  !
c								  !
c        and canonically conjugate momenta are:		          !
c								  !
c           k_z, k_r, r*k_phi.					  !
c								  !
c        Geometrical optics equation in these  variables  are     !
c        hamiltonian in form and they are  solved  by  4th-order  !
c        runge-kutta method.					  !
c        The code maintains conservation of the hamiltonian       ! 
c        function with given accuracy eps by using two different  !
c        numerical methods :                                      !
c        for isolv=1 - the solution of six ray equations          !
c         with correction of coordinates at each time step.       ! 
c        for isolv=2                                              !
c         the solution of the dispersion equation for one ray	  !
c         variable and the determination the other 5 variables	  !
c         from 5 geometric optics equations. The code determines  !
c         automatically which ray variable which must be          !
c         determined from dispertion relation.			  !
c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
c                                                                 !
c         the code is written in fortran-77 and does not require  !
c       any  special  subroutines  and  functions  from  fortran  !
c       libraries.						  !
c                                                                 !
c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
c                                                                 !
c                   version   19/09/00                            !
c                                                                 !
c-----------------------------------------------------------------!
c        it reads the input files: equilib.dat,genray.in  	  !
c-----------------------------------------------------------------!


CMPIINSERTPOSITION PROGRAMSTART


      PROGRAM GENRAY

c      implicit double precision (a-h,o-z)
      implicit none

      include 'param.i' ! specifies code parameters 
      include 'commons.i'
c      include 'transport_prof.i'  [added to commons.i, SAP080629]

CMPIINSERTPOSITION DECLARATION

cSm070718      dimension u(6),deru(6),aux(8,6)
      real*8  u(6),deru(6),aux(8,6),
     &energy,pitch,fdist,dfdx,dfdpitch,dfdp, !for call dskin
     &r,z,phi,fdens,fdens0,fmaxw,
     &zst1,rst1,phist1,alfast1,betast1,
     &cnteta,cnphi,      
     &win_0dsmax,ds,r0_em,z0_em,
     &psi_loc,rho_loc,clight,sum_emission,sum_emission_wall


      integer iraystop,nray,ndim,
     &initial,ihlf,n_r,n_z,ifreq,
     &i_bad_initial_conditions,n,
     &nrayelt_o_cutoff_emis,n0,igenray,
     &i_geom_optic_loc

c-----externals
      external outpt
      external rside1,rsideb1,outptb1,b,
     &fdens_fdist,fdens0_fdist,fdens_fkin2,
     &length_char,tempe,temperho,fpsi,rhopsi,r_2nd_harm,
     &dvarddz,vardens,
     & ddnsrho,densrho

      real*8 thetapol,psif,drhodz,dthetadz,dthetadr,drhodr,ddnsrho,b1
      real*8 b,dense,density_r_z_i,d_density_r_z_i_d_r,x,dxdr,dxdz,
     &d_density_r_z_i_d_z,drhopsi,
     &fdens_fdist,fdens0_fdist,fdens_fkin2,tempe,temperho,fpsi,rhopsi,
     &r_2nd_harm,zeffrho,
     &dense_no_RZ_spline

      integer length_char

      real*4 time_loop_ifreq_1,time_loop_ifreq_2,time_loop_ifreq,
     &time_before_rk,time_after_rk,time_rk,
     &time_genray_1,time_genray_2,
     &time_emission_2,
     &time_emission_1
c------------------------------------------------------------
cfor test CD_adj_LH_efficiency
      real*8 lh_cd_efficiency,cnpar,cnper,thetapol_l,
     &u_ph_karney,u1,efficien,temp_kev,unorm

      integer n_radial
cfor interpolation_chi
      real*8 u0,theta0,
     &chi,d_chi_d_u_out,d_chi_d_theta_out
      integer n_radial0
cSAP080711
c-----genray input file: genray.in or genray.dat
      character*10 genray_in_dat

cSAP081122
      real*8 
     &length_b

cSAP090205 to check subroutine sigma_edge_n_theta_pol
      integer i,i0r,j0r,i0z,j0z

      real*8  theta_pol_radian,
     &sigma_edge_n,d_sigma_edge_n_d_theta_pol,
     &d2_sigma_edge_n_d2_theta_pol

ctest for spline density art rz mesh
      real*8 dens_rho_l,dens_rz,d_norm,diff_dens,
     &dif_d_dens_dr,dif_d_dens_dz,
     &d_norm_r,d_norm_z,d_dens_rho_r,d_dens_rho_z,
     &d_dens_spl_r,d_dens_spl_z,
     & dens_rho_theta,d_dens_rho_theta_d_rho,
     & d_dens_rho_theta_d_theta,
     & dn_drho,dro_dpsi,
     & step_rz,d_p,d_m,deriv_l,r_p,r_m,z_p,z_m,
     & x_l,x_p,x_m,dxdr_l,dxdz_l,dxdr_d,dxdz_d,
     & rho_z_p,rho_z_m,rho_r_p,rho_r_m,     
     & dens_z_p,dens_z_m,dens_r_p,dens_r_m
      integer j,k,m
CMPIINSERTPOSITION INITIALIZATION

        call cpu_time(time_genray_1)

c---------------------------------------------------
c     Write out the version number
c--------------------------------------------------

      write(t_,1000) version
 1000 format(15x,"GENRAY VERSION: ",a)
      write(6,'(//16x,
     +          "=================================================")')
      if (length_char(t_) .gt. 512) stop 'GENRAY:Adjust length of t_'
      write(6,*) t_(1:length_char(t_))
      write(6,'(16x,
     +          "=================================================",/)')


CMPIINSERTPOSITION STARTBARRIER

c---------------------------------------------------
c     check the parameters in param.i
c--------------------------------------------------
      if (nrya.ne.(max(nxeqda,nyeqda)+4)) then
         write(*,*)'it should be nrya.eq.(max(nxeqda,nyeqda)+4)'
         write(*,*)'but nrya,nxeqda,nyeqda', nrya,nxeqda,nyeqd
         write(*,*)'change the parameter nrya in param.i'
         stop
      endif

c      if (nzy.ne.(max(npsi,nteta1)+4)) then
c         write(*,*)'it should be nzy.eq.(max(npsi,nteta1)+4)'
c         write(*,*)'but nzy,npsi,nteta1', nzy,npsi,nteta1
c         write(*,*)'change the parameter nzy in param.i'
c         stop
c      endif

cSAP091124      
c      if (nzy.ne.(max0(npsi4,nteta1)+4)) then 
      if (nzy.ne.(max0(npsi,nteta1)+4)) then
cSAP091124
c        write(*,*)'in param.i nzy.ne.max0(npsi4,nteta1)+4'
         write(*,*)'in param.i nzy.ne.max0(npsi,nteta1)+4'
         write(*,*)'nzy= ',nzy
cSAP091124
c        write(*,*)'max0(npsi4,nteta1)',max0(npsi4,nteta1)
         write(*,*)'max0(npsi,nteta1)=4',max0(npsi,nteta1)+4
         write(*,*)'Change nzy in param.i'
         stop
      endif

c      if (nwka.ne.(1+3*max(jxa,iya))) then
c--------the parameters for the distribution function spline aproximation   
c         write(*,*)'it should be nwka.eq.(1+3*max(jxa,,iya))'
c         write(*,*)'but nwka,jxa,iya',nwka,jxa,iya
c         write(*,*)'change the parameter nwka in param.i'
c         stop
c      endif

      
c-----the creation of default input data like in genray.dat file
      call default_in
      write(*,*)'genray.f after default_in'
      write(*,*)'i_resonance_curve_integration_method=',
     &           i_resonance_curve_integration_method

c-----check if input file is genray.in, then it will change
c     default data to genray.in file (MKSA) format  
      call transform_input_data_to_MKSA

c-----Initialize the value of nj, in case read_transport_prof not used.
      nj=0

c---- read all namelists from input genray.in or genray.dat file   
      call read_all_namelists(genray_in_dat,ndim,nray)

      write(*,*)'genray.f after read_all_ ndim ',ndim
c      stop 'genray.f after read_all_ ndim '

      write(*,*)'in genray.f genray_in_dat=', genray_in_dat
      write(*,*)'genray.f after read_all_ prmt ',prmt

      write(*,*)'genray.f after read_all_ ioxm',ioxm   
      write(*,*)'genray.f after read_all_ nray',nray  

      write(*,*)'genray.f after read_all_namelists data in /genr/'
      write(*,*)'r0x=',r0x
      write(*,*)'b0=',b0
      write(*,*)'outdat=',outdat
      write(*,*)'stat=',stat
      write(*,*)'mnemonic=',mnemonic
      write(*,*)'rayop=',rayop
      write(*,*)'dielectric_op=',dielectric_op
      write(*,*)'partner=',partner

c-----allocate data 
      call ainalloc

c-----test sigma_edge_n
      pi=4*datan(1.d0)
      write(*,*)' i_edge_dens_anal',i_edge_dens_anal
      if(i_edge_dens_anal.eq.2) then
c--------spline data for  sigmedgn_ar
         do i=1,n_pol_edge_dens
            theta_pol_radian=2.d0*pi/( n_pol_edge_dens-1)*(i-1)
            call sigma_edge_n_theta_pol(theta_pol_radian,
     &         sigma_edge_n,d_sigma_edge_n_d_theta_pol,
     &         d2_sigma_edge_n_d2_theta_pol)
            write(*,*)'i,theta_pol_radian,sigma_edge_n',
     &                 i,theta_pol_radian,sigma_edge_n
            write(*,*)'d_sigma_edge_n_d_theta_pol',
     &                 d_sigma_edge_n_d_theta_pol
            write(*,*)'d2_sigma_edge_n_d2_theta_pol',
     &                 d2_sigma_edge_n_d2_theta_pol
         enddo
       endif

c-----If input file is genray.in, then it will change
c     input data to genray.dat file format 
      if (genray_in_dat.eq.'genray.in')  then
         write(*,*)'genray.f before transform_genray_in_to_dat'
         call transform_genray_in_to_dat 
      endif
      write(*,*)'genray.f after tramnsform_genray ',prmt
c---------------------------------------------------------------
c     reading the eqdsk data
c     and creation of the coefficients for spline approximation
c     for: feqd, psi -magnetic field functions
c          zpllim(r),zminlim (r) - limmiter boundary
c---------------------------------------------------------------
      write(*,*)' genray.f before call equilib'
      call equilib
      write(*,*)' genray.f after call equilib'
      write(*,*)'NR',NR
c---------------------------------------------------------------
      write(*,*) 'genray.f before call rhospl'
      call rhospl     
      write(*,*) 'genray.f after call rhospl'
      write(*,*)'arpsi',arpsi
c----------------------------------------------------
c    compare poloidal and B field lengths 
c      do n=1,npsi     
       
c        call calc_length_b(arpsi(n),length_b)
c        write(*,*)'n,arpsi(n), rhopsi(arpsi(n))',
c     &             n,arpsi(n), rhopsi(arpsi(n))
c         write(*,*)'pollength,length_b',arrho_l(n)*totlength,length_b
c         if (n.gt.1) write(*,*)'length_b/pollength',
c     &                          length_b/(arrho_l(n)*totlength)
     
c      enddo
c      stop 'genray.f calc_length_b'
c--------------------------------------------------------------------
c     reading the name of the output file
c--------------------------------------------------------------------
      i1_=91
      open(i1_,file=outdat)
      iraystop=0
c-------------------------------------------------------------------
c     reading input data from genray.in file
      write(*,*) 'genray.f before call dinit_mr'
      write(*,*)'NR=',NR
      call dinit_mr(ndim,nray)
c-----allocate pointers at writencdf.i
c      write(*,*)'genray.f before  ainalloc_writencdf nray',nray
c      call ainalloc_writencdf_i(nray)
c      call ainalloc_write_i(nray)

      write(*,*)'genray.f after dinit_mr prmt=',prmt
      write(*,*)'genray !!!!!ndim',ndim
      write(*,*)'genray after dinit_mr nray=',nray
      write(*,*)'genray after dinit_mr nbulk',nbulk
      write(*,*)'v',v
      write(*,*)'w',w
      write(*,*)'genray.f after dinit_mr ioxm ',ioxm
      write(*,*)'genray.f after dinit_mr freqncy0',freqncy0
      do iray=1,nray         
         write(*,*)'1 iray,arzu0(iray),arru0(iray),arphiu0(iray)',
     &              iray,arzu0(iray),arru0(iray),arphiu0(iray)
      enddo
      write(*,*)'genray.fbefore n_wall.eq.1  n_wall',n_wall 

      if (n_wall.gt.1)then
c------------------------------------------------------------------
c        create additional points at the chamber wall
c-----------------------------------------------------------------
c        interpolate wall points at the wall mesh with additinal ponts 
c        r_wall_add(n_wall_add) z_wall_add(n_wall_add)
c        and calculate the number of points of this mesh: n_wall_add)
c        Result will be in fourbe.i
         call create_fine_mesh_for_chamber_wall_limiter_coordinates
         call add_horisontal_limiter_walls
         call MK_graph_chamber_wall
c         stop 'genray,f after  MK_graph_chamber_wall'
c--------------------------------------------------------------------
c        create RZ meshes: rr_add(nxeqd_add),zz_add(nyeqd_add)
c-------------------------------------------------------------------
         call creat_fine_2D_poloidal_mesh
c--------------------------------------------------------------------
c        calculate distance from RZ mesh points to chamber wall:
c        distance_to_wall(nxeqd_add,nyeqd_add)
c-------------------------------------------------------------------
         write(*,*)'genray.f before distance_for_wall'
         call distance_for_wall  
         write(*,*)'genray.f after distance_for_wall'
c--------test fast subroutine: it gave wrong result 
c         call distance_for_wall_1
c         stop 'genray.f after distance_for_wall_1'
c-------------------------------------------------------------------
c        Calculate density array:  density_r_z(nxeqd_add,nyeqd_add,nbulk)
c        at (rr_add,zz_add) mesh
c        For( n_wall.gt.1) case create density fall near the chamber wall.
c-------------------------------------------------------------------
          call density_at_zr_plane 
c-------------------------------------------------------------------
c         calculate density spline coefficients 
c         at RZ mesh using array density_r_z
c-------------------------------------------------------------------
         write(*,*)'genray.f before splcoef_density_r_z'
         call splcoef_density_r_z
         write(*,*)'genray.f after splcoef_density_r_z'
c         stop 'genray.f after splcoef_density_r_z'
       endif

       goto 17
c------test of RZ density spline      for n_wall >0
       if (n_wall.ge.1) then

       phi=0.d0
       phi=1.d0
       m=0
       m=1
       do k=1,nbulk
         d_norm=0.d0
         d_norm_r=0.d0  
         d_norm_z=0.d0
         dif_d_dens_dr=0.d0
         dif_d_dens_dz=0.d0
         i0r=0
         j0r=0
         i0z=0
         j0z=0
         do i=1,nxeqd_add
           do j=1,nyeqd_add
             write(*,*)'k,i,j,zz_add(j),rr_add(i)',
     &                  k,i,j,zz_add(j),rr_add(i)
             z=zz_add(j)
             r=rr_add(i)
             bmod=b(z,r,k) !calculate rho

c             write(*,*)'genray.f before dense_no_RZ_spline'
             dens_rho_l=dense_no_RZ_spline(z,r,phi,k)
             write(*,*)'genray.f before dense dens_rho_l',dens_rho_l

             dens_rz=dense(z,r,phi,k)
             write(*,*)'genray.f after dense dens_rz', dens_rz

             if(dabs(distance_to_wall(i,j,m)).le.1.d-3) then
                write(*,*)'i,j,z,r,rhodistance_to_wall(i,j,m)',
     &                  i,j,z,r,rho,distance_to_wall(i,j,m)
                write(*,*)'dens_rho_l,dens_rz',dens_rho_l,dens_rz
             endif
 
             d_norm=d_norm+dabs(dens_rho_l-dens_rz)
             diff_dens=dens_rho_l-dens_rz
            
c------------derivatives
cSAP090408
c             write(*,*)'derivatives rho',rho

             if (rho.gt.1.d0-1.d-10) then
                thetapol_l=thetapol(z,r) ! -pi <thetapol =<pi

                if (thetapol_l.lt.0d0) then
                    thetapol_l=thetapol_l+2*pi !pi< theta_pol<2pi
                endif
cSAP090408
c                write(*,*)'before dens_rho_theta_LCFS'

                call dens_rho_theta_LCFS(rho,thetapol_l,k,
     &          dens_rho_theta,d_dens_rho_theta_d_rho,
     &          d_dens_rho_theta_d_theta)

cSAP090408
c                write(*,*)'after dens_rho_theta_LCFS'

                d_dens_rho_r=d_dens_rho_theta_d_rho*drhodr(z,r,phi)
     &              +d_dens_rho_theta_d_theta*dthetadr(z,r)

                d_dens_rho_z=d_dens_rho_theta_d_rho*drhodz(z,r,phi)
     &              +d_dens_rho_theta_d_theta* dthetadz(z,r)
cSAP090408
                write(*,*)'d_dens_rho_r,d_dens_rho_z',
     &                     d_dens_rho_r,d_dens_rho_z

                goto 15
c---------------numerical derivative d_dens_rho_theta_d_rho
                step_rz=1.d-4
                step_rz=1.d-6
                call dens_rho_theta_LCFS(rho+step_rz,thetapol_l,k,
     &          x_p,d_dens_rho_theta_d_rho,
     &          d_dens_rho_theta_d_theta)
                call dens_rho_theta_LCFS(rho-step_rz,thetapol_l,k,
     &          x_m,d_dens_rho_theta_d_rho,
     &          d_dens_rho_theta_d_theta)
                dxdz_d=(x_p-x_m)/(2.d0*step_rz) !d_dens_drho numerical
                write(*,*)'d_dens_rho_theta_d_rho,dxdz_d',
     &                     d_dens_rho_theta_d_rho,dxdz_d
c---------------numerical derivative d_dens_rho_theta_d_theta
                call dens_rho_theta_LCFS(rho,thetapol_l+step_rz,k,
     &          x_p,d_dens_rho_theta_d_rho,
     &          d_dens_rho_theta_d_theta)
                call dens_rho_theta_LCFS(rho,thetapol_l-step_rz,k,
     &          x_m,d_dens_rho_theta_d_rho,
     &          d_dens_rho_theta_d_theta)
                dxdz_d=(x_p-x_m)/(2.d0*step_rz) !d_dens_drho numerical
                write(*,*)'d_dens_rho_theta_d_theta,dxdz_d',
     &                     d_dens_rho_theta_d_theta,dxdz_d
c---------------numerical derivatives drhodr(z,r,0.d0)-----------------
                bmod=b(z,r+step_rz,k) 
                x_p=rho
                bmod=b(z,r-step_rz,k)
                x_m=rho
                dxdr_d=(x_p-x_m)/(2.d0*step_rz) !d_rho/d_r numerical
                write(*,*)'drhodr(z,r,phi),dxdr_d',
     &                     drhodr(z,r,phi),dxdr_d
c---------------numerical derivatives drhodz(z,r,0.d0)-----------------
                bmod=b(z+step_rz,r,k) 
                x_p=rho
                bmod=b(z-step_rz,r,k)
                x_m=rho
                dxdz_d=(x_p-x_m)/(2.d0*step_rz) !d_rho/d_z numerical 
                write(*,*)'drhodz(z,r,phi),dxdz_d',
     &                     drhodz(z,r,phi),dxdz_d
c----------------------------------------------------------------
             else
               psi_loc=psif(z,r)
               dro_dpsi=drhopsi(psi_loc)
               dn_drho=ddnsrho(rho,k)
               d_dens_rho_r=dn_drho*dro_dpsi*dpdrd
               d_dens_rho_z=dn_drho*dro_dpsi*dpdzd
             endif
c------------density derivatives using spline
 15          continue
cSAP090409
c             write(*,*)'genray.f before d_density_r_z_i_d_r k,m',k,m
             d_dens_spl_r=d_density_r_z_i_d_r(z,r,phi,k)
             d_dens_spl_z=d_density_r_z_i_d_z(z,r,phi,k)
             goto 16
c             step_rz=1.d-5
             step_rz=1.d-4
c-------------numerical d_dens_d_z from spline rz density            
             x_p=density_r_z_i(z+step_rz,r,phi,k)
             x_m=density_r_z_i(z-step_rz,r,phi,k)
             dxdz_d=(x_p-x_m)/(2.d0*step_rz)

             write(*,*)'numer der z spl'
             write(*,*)'x_p,z+step_rz,x_m,z-step_rz,dxdz_d',
     &                  x_p,z+step_rz,x_m,z-step_rz,dxdz_d

             x_p=density_r_z_i(z,r+step_rz,phi,k)
             x_m=density_r_z_i(z,r-step_rz,phi,k)
             dxdr_d=(x_p-x_m)/(2.d0*step_rz)

             write(*,*)'numer der r spl'
             write(*,*)'x_p,r+step_rz,x_m,r-step_rz,dxdr_d',
     &                  x_p,r+step_rz,x_m,r-step_rz,dxdr_d

             write(*,*)'num der spl dxdz_d,dxdr_d',dxdz_d,dxdr_d

c-------------numerical d_dens_d_z from function dense             
             bmod=b(z+step_rz,r,k) 
             x_p=dense(z+step_rz,r,phi,k)
             bmod=b(z-step_rz,r,k) 
             x_m=dense(z-step_rz,r,phi,k)
             dxdz_d=(x_p-x_m)/(2.d0*step_rz)

             write(*,*)'numer der z dense'
             write(*,*)'x_p,z+step_rz,x_m,z-step_rz,dxdz_d',
     &                  x_p,z+step_rz,x_m,z-step_rz,dxdz_d

             bmod=b(z,r+step_rz,k) 
             x_p=dense(z,r+step_rz,phi,k)
             bmod=b(z,r-step_rz,k) 
             x_m=dense(z,r-step_rz,phi,k)
             dxdr_d=(x_p-x_m)/(2.d0*step_rz)

             write(*,*)'numer der r dense'
             write(*,*)'x_p,r+step_rz,x_m,r-step_rz,dxdr_d',
     &                  x_p,r+step_rz,x_m,r-step_rz,dxdr_d


             write(*,*)'num der dense dxdz_d,dxdr_d',dxdz_d,dxdr_d
c---------------------------------------------------------

 16          continue
             if (dif_d_dens_dr.lt.dabs(d_dens_rho_r-d_dens_spl_r)) then
                i0r=i
                j0r=j
                dif_d_dens_dr=dabs(d_dens_rho_r-d_dens_spl_r)
             endif

             if (dif_d_dens_dz.lt.dabs(d_dens_rho_z-d_dens_spl_z)) then
                i0z=i
                j0z=j
                dif_d_dens_dz=dabs(d_dens_rho_z-d_dens_spl_z)
             endif

             d_norm_r= d_norm_r+dabs(d_dens_rho_r-d_dens_spl_r)
             d_norm_z= d_norm_z+dabs(d_dens_rho_z-d_dens_spl_z)

             if (dabs(distance_to_wall(i,j,0)).le.1.d-3) then
       write(*,*)'d_dens_rho_r,d_dens_spl_r',d_dens_rho_r,d_dens_spl_r
       write(*,*)'d_dens_rho_z,d_dens_spl_z',d_dens_rho_z,d_dens_spl_z
             endif

           enddo
         enddo
         write(*,*)'genray.f k d_norm,d_norm_r,d_norm_z',
     &                       k,d_norm,d_norm_r,d_norm_z
         write(*,*)'genray.f dif_d_dens_dr,i0r,j0r',
     &                       dif_d_dens_dr,i0r,j0r
         write(*,*)'genray.f dif_d_dens_dz,i0r,j0z',
     &                       dif_d_dens_dz,i0z,j0z


       enddo
 
       endif !nwall>0
c------end test
 17    continue
c       stop 'genray.f after compare splcoef_density_r_z'
c-------------------------------------------------
c     compare two different splines for b calculations
c      call  test_b_field
c      stop 'genray.f after  test_b_field'
c-------------------------------------------------------------------
c     test of non-maxwellian distribution
c     with the 3D distribution function f written by CQL3D
      do iray=1,nray         
         write(*,*)'2 iray,arzu0(iray),arru0(iray),arphiu0(iray)',
     &              iray,arzu0(iray),arru0(iray),arphiu0(iray)
      enddo
      goto 30

      write(*,*)'genray.f i_diskf',i_diskf
     
      if (i_diskf.ne.0) then
          write(*,*)'i_diskf= ',i_diskf
ctest
         initial=1
         call dskin(initial,energy,pitch,rho,
     .   fdist,dfdx,dfdpitch,dfdp,1)
         write(*,*)'diskf file was written'
c
      
c         call test_fdist

         r=1.50d0
         z=0.0d0
         phi=0.d0
         write(*,*)'!!!!!!! -1'
         fdens0=fdens0_fdist(r,z,phi)
         write(*,*)'in genray r,z,fdens0_fdist',r,z,fdens0 
         fdens=fdens_fdist(r,z,phi)
         write(*,*)'in genray r,z,fdens_fdist',r,z,fdens

         r=1.20d0
         z=0.0d0
         write(*,*)'!!!!!!! -2'
         fdens0=fdens0_fdist(r,z,phi)
         write(*,*)'in genray r,z,fdens0_fdist',r,z,fdens0 
         fdens=fdens_fdist(r,z,phi)
         write(*,*)'in genray r,z,fdens_fdist',r,z,fdens
 

         r=2.0d0
         z=0.1d0
         write(*,*)'!!!!!!! -3'
         fdens0=fdens0_fdist(r,z,phi)
         write(*,*)'in genray r,z,fdens0_fdist',r,z,fdens0 
         fdens=fdens_fdist(r,z,phi)
         write(*,*)'in genray r,z,fdens_fdist',r,z,fdens
 

         fdens=fdens_fkin2(1,1,r,z)
         write(*,*)'in genray fdens_fkin2(1,5,r,z)',fdens 
         
ctest
         energy=0.5d0
         pitch=0.5d0 
         rho=0.5d0
         write(*,*)'!!!!energy,pitch,rho',energy,pitch,rho
         call dskin(0,energy,pitch,rho,
     .   fdist,dfdx,dfdpitch,dfdp,2)
         write(*,*)'fdist,dfdx,dfdp,dfdpitch',
     .   fdist,dfdx,dfdp,dfdpitch
         write(*,*) 'in genray after dskin before stop'
         call fmaxw_en(energy,rho,fmaxw,dfdx)
c         fmaxw=fmaxw_en(energy,rho)
         write(*,*)'genray.f fmaxw,dfdx',fmaxw,dfdx 
         

c         stop
cendtest
      endif
 30   continue
c--------------------------------------------------------------
 

c-----------------------------------------------------------------------
c     For the plotting the output Toray data.
c     READs the data from toray (old_3d.dat) and creates genray.bin file     
c     call read3d(15)
c     write(*,*)'genray.f after read3d'
c     call MK_GRAPT (1,1)
c     write(*,*)'genray.f after mk_grapt'
c-------------------------------------------------------------


c-------------------------------------------------------------------
c      calculations of contours bmod(z,r)=const 1/y_i(z,r)=1,2,..
c      call contourb
c      write(*,*)'in genray before contrb2'
c      call contrb2
c      write(*,*)'write after contourb'
c-------------------------------------------------------------------
c     set zero to arrays power and current
c     for subroutine p_c_prof
c------------------------------------------
      do iray=1,nray         
         write(*,*)'3 iray,arzu0(iray),arru0(iray),arphiu0(iray)',
     &              iray,arzu0(iray),arru0(iray),arphiu0(iray)
      enddo
      write(*,*)'in genray ionetwo',ionetwo
      if(ionetwo.eq.1) then
         call onetwoini
      endif

c-------------------------------------------------------------------
c     creation of the circles on horizontal plane (X,Y) with
c     radiuses rmin,rmax,ra=xma (for tokamak toroidal section
c     graphic picture).Output:XT(3,NP+1),YT(3,NP+1) in common gr.cb
      call gr3
c------------------------------------------------------------------
      call output_con1

c---------------------------------------------------------------
c     the loop on all rays
c---------------------------------------------------------------
c---------------------------------------------------------------
c     Initialize arrays for Runge-Kutta subroutine
      call arrays(ndim,deru,prmt,ihlf)
c-----------------------------------------------------------------
      if (isolv.eq.1) then
        write(*,*)'the runge-kutta solution of 6 hamiltonian equations
     1  with correction which gives hamiltonian conservation'
        write(*,*)'accuracy of the hamiltonian conservation
     1	in correction procedure epscor=',prmt(4)
      endif

      if (isolv.eq.2) then
        write(*,*)'the runge-kutta solution of 5 hamiltonian equations
     1  and the solution of the dispersion relation for the sixth
     2  ray variable'
      endif

      write(*,*)'genray nray=',nray
c      if (nraya.lt.nray) then
c         write(*,*)'genray.f: nray=',nray,'nraya=',nraya
c         write(*,*)'nraya.lt.nray, inrease nraya in param.i'
c         stop
c      endif  

CMPIINSERTPOSITION ENDBARRIER

c
c-----Construct names of .txt and .nc ray data files
      if( length_char(mnemonic).gt.124)
     1                         stop 'Adjust mnemonic in genray.f'
      write(filetxt,1001) mnemonic(1:length_char(mnemonic))
 1001 format(a,".txt")
      write(filenc,1002) mnemonic(1:length_char(mnemonic))
 1002 format(a,".nc")
c
c     open text file for 3d FP code
      if(rayop.eq."text" .or. rayop.eq."both") then
        i_=92
        open(i_,file=filetxt)
      endif
c-----preparing data for output mnemonic.txt and mnemonic.nc file
      write(*,*)'in genray.f before write3d1 nray',nray
      call write3d1(nray)      
      write(*,*)'in genray.f sub after write3d1 nrayl=',nrayl
c----------------------------------------------------------------
c-----open PGplot
      call plotinit

c-----plot magnetic field contours to plot.ps file
      n_r=100
      n_z=100
      if(i_plot_b.eq.1) then ! plotting b,n,t in plot.ps file
         write(*,*)'genray.f before map_b'
         write(*,*)'nbulk',nbulk
         write(*,*)'v',v
         write(*,*)'w',w 
         write(*,*)'genray.f before map_b'
         call map_b(n_r,n_z)   
         write(*,*)'genray.f after map_b'
c--------------------------------------------------------------------
c       plot frequencies along the stright line of length dist_freq [m]
c       with the edge point z_freq,r_freq [m]
c       and directed by angles alpha_freq,beta_freq [degree]
c------------------------------------------------------------------
c ARIES
c      z_freq=0.0d0
c      r_freq=5.7d0
c      dist_freq=4.7d0
c      alpha_freq=180.0d0
c NSTX
c      z_freq=0.0d0
c      r_freq=1.49d0
c      dist_freq=1.28d0 !the length of the stright line

c      alpha_freq=180.0d0
c      beta_freq=90.0d0
c      nsteps_freq=780
c      n_ec_harmonics_freq=6
c      max_plot_freq200.d0
       call plot_fcefuh(z_freq,r_freq,alpha_freq,beta_freq,dist_freq,
     &       nsteps_freq,n_ec_harmonics_freq,npar_freq,max_plot_freq)
c         stop 'genray.f after plot_fcefuh'
      endif
c---------------------------------------------------------------
c     plot fig.1 for Ehst-Karney efficiency
c
c      write(*,*)'genray.f before plot_1_Karney'
c      call plot_1_Karney
c      write(*,*)'genray.f after plot_1_Karney'
c      stop
c      call plot_1_ADJ
c
c      See also, below:call plot_1_ADJ_Karney
c---------------------------------------------------------------
c     calculate the OX optimal directions of the EC cone central ray
      write(*,*)'genray.f before  gr_OX_optimal_direction'
      if (i_ox.eq.1) then
cSAP080422
         ifreq_write=1 !it is used in dinit_1ray
         call gr_OX_optimal_direction(ndim)
      endif
c---------------------------------------------------------------
      write(*,*)'genray.f before   adj_chi_function'
      write(*,*)'genray.f i_adj=',i_adj
      if (i_adj.eq.1) then  
         if (i_calculate_or_read_adj_function.eq.1) then
c----------calculate adj chi function used for current drive efficiency
           call adj_chi_function
c          write(*,*)'genray.f ua',ua
c          write(*,*)'th0a',th0a
c          stop 'adj_chi_function'
        endif
c---------------------------------------------------------
c-------read chi function from the file iout5
        call read_iout5_chi

c-------calculate CD conductivity
c        write(*,*)'genray.f 1 ua',ua
c        write(*,*)'th0a',th0a 
        if (i_calculate_or_read_adj_function.eq.1) then  
          call DC_electric_field_adj_conductivity
        endif
        if (i_calculate_or_read_adj_function.eq.0) then  
          call read_iout3_chi
        endif
cSAP080205
c        goto 110
c------------------------------------------------------------
c       calculate numerical arrays of derivatives d_chi_du,d_chi_d_theta
c       from chi function
c------------------------------------------------------------ 
        write(*,*)'genray.f before interpolation_chi'
        call interpolation_chi(1,n_radial0,u0,theta0,
     &  chi,d_chi_d_u_out,d_chi_d_theta_out) 
        write(*,*)'genray.f after interpolation_chi'
c-------------------------------------------------------------
c       calculate spline coefficients for chi 2D function
c       for all radial points
c--------------------------------------------------------------
        write(*,*)'genray.f before splcoef_chi'
        call  splcoef_chi

        write(*,*)'genray.f after splcoef_chi'

c        stop 'stop after after splcoef_chi'
c----------------------------------------------------
c      creates data (arrays) for plot like Fig. 1
c      at Karney article Nuclear Fusion 1991 p. 1934
c      using ADJ efficiency
c--------------------------------------------------- 

        write(*,*)'genray.f before plot_1_ADJ_Karney'

        call plot_1_ADJ_Karney

        write(*,*)'genray.f after plot_1_ADJ_Karney'

c        stop 'plot1 adj_Karney'

        goto 101
ctest efficiency fo LH case
        clight=2.99792458d10              !light speed [cm/sec]
        u_ph_karney=2.d0                  !LH phase velocity normalized to unorm
        u_ph_karney=4.d0 
c        u_ph_karney=1.d0 
        
        u1=u_ph_karney/dsqrt(2.d0) 
        thetapol_l=0.d0
c        do n_radial=1,npsi0
        do n_radial=2,2
          write(*,*)'genray.f n_radial,psis(n_radial)',
     &                        n_radial, psis(n_radial)
          rho_loc=rhopsi(psis(n_radial))
          temp_kev=temperho(rho_loc,1)
          unorm=dsqrt(temp_kev/t)*dsqrt(1.6022d0/0.91095d0)*1.d9 ![sm/sec] sqrt(T/m) 
          cnpar=(clight/unorm)/u_ph_karney
          cnpar=dsqrt(1.d0+((clight/unorm)/u_ph_karney)**2)
          
          write(*,*)'genray.f rho_loc,unorm,cnpar',rho_loc,unorm,cnpar
          write(*,*)'zeffrho(rho_loc)',zeffrho(rho_loc)
          efficien=8.d0/(5.d0+zeffrho(rho_loc))*u1*u1 !test
          write(*,*)'asimptotic efficien',efficien

          call CD_adj_LH_efficiency_anal_1(u_ph_karney,cnpar,
     &    n_radial,thetapol_l,
     &    unorm,
     &    lh_cd_efficiency)
          write(*,*)'unorm',unorm
          write(*,*)'lh_cd_efficiency',lh_cd_efficiency
        enddo
 101  continue
      endif ! i_adj.eq.1

c      stop 'stop after adj_chi_function'
c----------------------------------------------------------------

CMPIINSERTPOSITION JUSTBEFORETHELOOP
      write(*,*)'genray.f before do 20 nray=',nray

      do iray=1,nray         
         write(*,*)'4 iray,arzu0(iray),arru0(iray),arphiu0(iray)',
     &              iray,arzu0(iray),arru0(iray),arphiu0(iray)
      enddo

      i_total_bad_initial_conditions=0
      power_launched=0.d0

       do 20 iray=1,nray
c      do 20 iray=67,67
c       do 20 iray=20,20
c      do 20 iray=27,27
c      do 20 iray=4,4
c       do 20 iray=50,50

CMPIINSERTPOSITION STARTTHELOOP

c--------the loop over all rays        
         write(i1_,11)iray
 11      format('####  iray=',i3)

         write(*,*)'### iray',iray

         write(*,*)'0 genray.f ioxm',ioxm

CMPIINSERTPOSITION PRINTHEADER

ctest for hamiltonian mapping
c         write(*,*)'genray before maphmnri'
c         ihermloc=1
c         ye=0.900751703
c         xe=2.52756889
c         write(*,*)'r0x',r0x
c         r=0.1662d+01/r0x
c         z=0.4916d-05/r0x
c         phi=0.8992d-01
c         bmod=b(z,r,phi)
c         write(*,*)'genray rho=',rho
c         te=tempe(z,r,phi,1)
c         write(*,*)'te=',te
c         stop
c         cnpar=0.762634654
c         cnper=25.3389475
c         delnper=0.1d0
c         delnperim=0.002d0
c         call maphmnri(ye,xe,te,cnpar,cnper,delnper,delnperim,ihermloc)
c         write(*,*)'genray after  maphmnri'
c         stop
cendtest

         if (i_emission.eq.0) then
            nfreq=1
            write(*,*)'in genray i_emission=0, no emission calculation'
            write(*,*)'genray.f put nfreq=1' 
         endif

c         goto 26    
         i_geom_optic_loc=i_geom_optic
         do 25 ifreq=1,nfreq
c           do 25 ifreq=1,1
            i_geom_optic=i_geom_optic_loc

c for Nazikian case !070802
c           if (ifreq.gt.2) id=2

CMPIINSERTPOSITION STARTEMISSION
cDm070112
            ifreq_write=ifreq ! to set in write.i

            write(*,*)'genray.f ifreq_write',ifreq_write

            call cpu_time(time_loop_ifreq_1)

c-----------the loop over all emission frequencies for i_emission=1
            write(*,*)'### iray= ',iray,'ifreq= ',ifreq
c-----------set the frequency frqncy=wfreq(ifreq) and w0,v0,w0,v(i),w(i)
            call set_freq(ifreq)

            write(*,*)'genray.f istart=',istart

            if(istart.eq.1) then
c ------------EC wave
              zst1=zstj(iray) 
              rst1=rstj(iray) 
              phist1=phistj(iray) 
              alfast1=alphaj(iray)
              betast1=betaj(iray)
              write(*,*)'genray before dinit_1ray ,zst1,rst1,phist1',
     1	             zst1,rst1,phist1,'alfast1,betast1',alfast1,betast1
              write(*,*)'in genray iray,powj(iray)',iray,powj(iray)
              powini=powj(iray)

              write(*,*)'genray.f before dinit_1ray ioxm ',ioxm  
              call dinit_1ray(zst1,rst1,phist1,alfast1,betast1,
     1                       cnteta,cnphi,u,iraystop)

              i_bad_initial_conditions=0
              write(*,*)'genray.f after dinit_1ray',
     &        'i_bad_initial_conditions',i_bad_initial_conditions
              write(*,*)'genray.f after dinit_1ray ioxm ',ioxm

              if (iraystop.eq.1) then
	        write(*,*)'iray=',iray,'iraystop=1
     1                  bad initial conditions'
                nrayelt=0
                i_bad_initial_conditions=1
	        goto 24
	      end if
	    endif !istart.eq.1

            if((istart.eq.2).or.(istart.eq.3))then
c ------------LH and FW waves >istart=2
c ------------ECR O_X mode conversion special case: istart=31 
              write(*,*)'2 in genray before dinit_1ray iray',iray
	      write(*,*)'2 in genray before dinit_1ray zu0,ru0,phiu0',
     1	            arzu0(iray),arru0(iray),arphiu0(iray)
              powini=powinilh(iray)
              write(*,*)'alfast1,betast1,arntheta(iray),arnphi(iray)',
     1                 alfast1,betast1,arntheta(iray),arnphi(iray)
              write(*,*)'!!!genray before dinit_1ray'

              write(*,*)'genray.f before dinit_1ray ioxm ',ioxm

              call dinit_1ray(arzu0(iray),arru0(iray),arphiu0(iray),
     1	      alfast1,betast1,arntheta(iray),arnphi(iray),u,iraystop)

              write(*,*)'!!!genray after  dinit_1ray ioxm'

              write(*,*)'genray.f after dinit_1ray ioxm ',ioxm

	    endif !istart.eq.2 .or. istart.eq.3

cSAP090601
c test 
c            iraystop=1           
c            write(*,*)'genray.f after test iraystop=1 dinit_1ray'
cendtes
            i_bad_initial_conditions=0
            write(*,*)'genray.f after dinit_1ray ',
     &      'i_bad_initial_conditions=',i_bad_initial_conditions            

	    if (iraystop.eq.1) then
	       write(*,*)'iray=',iray,'iraystop=1
     1                  bad initial conditions'
               i_bad_initial_conditions=1
               nrayelt=0

	       goto 24
	    end if
  
	    prmt(7)=prmt(1)+prmt(6)
     
c----------------------------------------------------------
c           call b() to calculate the small radius rho (inside b())
c           the result will be in common block  one.i
c           rhooldsc will be used in the n_perp_scattering procedure
c           rhooldsc will be in common block scatnper.i 
c-----------------------------------------------------------
            bmod=b(u(1),u(2),u(3))
            rhooldsc=rho

CMPIINSERTPOSITION STARTRUNGEKUTTA

            call cpu_time(time_before_rk)

            nstep_rk=1 ! initialize the number of Runge-Kutta time step 
            
            if (isolv.eq.1) then
c--------------------------------------------------------------
c              The Runge-Kutta solution of 6 hamiltonian equations
c              with correction which gives 
c              hamiltonian conservation with
c              accuracy epscor=prmt(4)
c--------------------------------------------------------------
               if(irkmeth.eq.0) then
c                4_th order Runge-Kutta method with constant time step
                 call drkgs(prmt,u,deru,ndim,ihlf,rside1,outpt,aux)
               endif
              
               if(irkmeth.eq.1) then
c                 5-th order Runge-Kutta method with variable time step,
                  call drkgs1(prmt,u,deru,ndim,ihlf,rside1,outpt,aux)
               endif
               if(irkmeth.eq.2) then
c                 4th order Runge-Kutta with variable time step,
c                          time step can be reduce or enlarge
                  write(*,*)'genray.f before  drkgs2 ioxm.ndim',
     &                                               ioxm,ndim
                  call drkgs2(prmt,u,deru,ndim,ihlf,rside1,outpt,aux,
     &                        i_output)
                  write (*,*)'genray.f after call drkgs2 ifreq,nfreq',
     &                                                   ifreq,nfreq
                  
               endif
            endif ! isolv.eq.1
          
            if (isolv.eq.2) then
c-------------------------------------------------------------------
c              The Runge-Kutta solution of 5 hamiltonian equations
c              and the solution of the dispersion relation for the sixth
c              ray variable'
c-------------------------------------------------------------------------
	       call rkb1(prmt,u,deru,ndim,ihlf,rsideb1,outptb1,aux)
c------------------------------------------------------------------------
            endif ! isov.eq.2
                          
 10         format(a/a)

            call cpu_time(time_after_rk)
            time_rk=time_after_rk-time_before_rk
            write(*,*)'time_initial conditions',
     &                 time_before_rk-time_loop_ifreq_1
            write(*,*)'time_rk',time_rk


CMPIINSERTPOSITION ENDRUNGEKUTTA
           
c------------------------------------------------------------------
c           creation of the file: genray.bin for xdraw
c           input data from common blocks gr.cb and write
c           write(*,*)'in genray before call mk_graph iray',iray

c            if (((i_emission.eq.0).or.(ifreq.eq.ifreq0)).
c     +         or.(nfreq.eq.1)) then
            if (i_emission.eq.0) then
               write(*,*)'genray.f before mk_graph'
cSAP090313
c              call mk_graph(iray,nray,ifreq,nfreq,nbulk)
               write(*,*)'genray. f (i_emission.eq.0) before mk_graph'
               call mk_graph(iray,nray,ifreq)

               call mk_gr3d(iray,nray)
c              write(*,*)'in genray after call mk_graph iray',iray
c	       write(*,*)'in genray before GRAPHnpar!!!!!!!!!!!!!!!!!!!!'
c              creation of the file: npar.bin for xdraw
               call GRAPHnpr
               if (iwcntr.eq.1) then
c                 calculation of contours wb_c = consts
c                 write(*,*)'in genray after before mk_graph iray',iray
                  call mk_grapc(iray,iwopen,iwj)
c                 write(*,*)'in genray after call mk_grapc iray',iray
	       endif
            endif
            if (i_emission.eq.1) then
               write(*,*)'genray.f before call mk_graph'
cSAP090313
c              call mk_graph(iray,nray,ifreq,nfreq,nbulk)
               write(*,*)'genray. f (i_emission.eq.1) before mk_graph' 
               call mk_graph(iray,nray,ifreq)
               write(*,*)'genray.f after call mk_graph'
            endif 
c--------------------------------------------------------------------
c           calculation of power(array spower(NR)) and
c           current(array scurrent(NR)) radial profiles
c           as sum of profiles Sum(i=1,iray)

c---------------------------------------------------------------------
            write(*,*)'ionetwo=',ionetwo
	    if(ionetwo.eq.1) then
               call sonetwo
	    endif
c------------------------------------------------------------
            if (i_emission.eq.1) then
cSAP080422
               if (nrayelt.lt.2) then
                  write(*,*)'in genray.f nrayelt=',nrayelt
                  write(*,*)'nrayelt.lt.2'
                  write(*,*)'The code will not calculate emission'
                  goto 25
               endif
               call cpu_time(time_emission_1)                
c--------------spline coeficients calculations for ray data along the ray
               call spl_ray

c--------------emission calclulation   
               write(*,*)'genray.f before emission nrayelt_o_cutoff',
     &         nrayelt_o_cutoff

c               do n=1,nrayelt
c               write(*,*)'n,wsn(n)',n,wsn(n)
c               enddo

               call emission(tol_emis,nrayelt,nrelta,wsn,wal_emis,
     +                       wj_emis,wnray,win_sn,win_0,
     +                       wi_0(iray,ifreq),wi_0sn,wtaun_em,
     +                       nrayelt_emis,
     &                nrayelt_o_cutoff,transm_ox,nrayelt_o_cutoff_emis)  

c               write(*,*)'genray.f aft emission ifreq,nrayelt_o_cutoff',
c     &         ifreq,nrayelt_o_cutoff

c               write(*,*)'genray.f aft emis ifreq,iray,wi_0(iray,ifreq)'
c     &         ,ifreq,iray,wi_0(iray,ifreq)

c               write(*,*)'genray.f after emission  nrayelt_emis',
c     &         nrayelt_emis

c              do n=1,nrayelt_emis
c                write(*,*)'n,wi_0sn(n)',n,wi_0sn(n)
c              enddo 
               
c               write(*,*)'in genray.f nrayelt,nrayelt_emis,
c     +         wi_0(iray,ifreq)',
c     +         nrayelt,nrayelt_emis,wi_0(iray,ifreq)

               

c              do n=1,nrayelt_emis
c                write(*,*)'n,wr_em(n),win_sn(n),win_0(n),wtaun_em(n)',
c     +          n,wr_em(n),win_sn(n),win_0(n),wtaun_em(n)
c              enddo   

c              wtau_em is the optical depth: 
c              a) from one pass, if the ray had the reflection point 
c              b) from part of the ray path, if there was full absorption
c                 before one reflection
               wtau_em(iray,ifreq)=wtaun_em(nrayelt_emis-1)

cSm070120      wi_0 was devided by wnray(1) in emission.f
c               wi_0(iray,ifreq)=wi_0(iray,ifreq)/wnray(1)**2
               write(*,*)'genray.f wnray(1) ',wnray(1)

               wi_0t(iray,ifreq)=wi_0(iray,ifreq)/
     +               (1.d0-wallr*dexp(-wtau_em(iray,ifreq)))

c--------------write the emission output data to emis.bin file for plotting
               write(*,*)'genray.f before mk_gremis'
c               write(*,*)'wsn',wsn
c               write(*,*)'win_0',win_0
c               write(*,*)'genray.f bef mk_gremis iray,nray,ifreq,nfreq'
c     &                                          ,iray,nray,ifreq,nfreq
               call mk_gremis (iray,nray,ifreq,nfreq)
c--------------------------------------------------------------------
c              Find the ray point P0 with the maximal value of flux
c              (at the plasma boundary from n-th bin) divided by 
c              the bin length ds : In0/ds
c              Calculate the plasma temperatute in this point P0.
c--------------------------------------------------------------------
               n0=1
               win_0dsmax=0.d0

               do n=1,nrayelt_emis-1
                  ds=wsn(n+1)-wsn(n) !the bin length       
c                  write(*,*)'n,wsn(n+1),wsn(n),win_0(n),ds',
c     +            n,wsn(n+1),wsn(n),win_0(n),ds
c                  write(*,*)'genray.f n,n0,win_0dsmax,win_0(n)/ds',
c     +            n,n0,win_0dsmax,win_0(n)/ds
c                  if (ds.gt.1.d-18) then 
                  if (ds.gt.1.d-12) then
                    if (win_0dsmax.lt.win_0(n)/ds) then
                      win_0dsmax=win_0(n)/ds
                      n0=n                  
                    endif
                  endif
               enddo

c               write(*,*)'genray.f ifreq,nrayelt_emis,n0,win_0dsmax',
c     &         ifreq,nrayelt_emis,n0,win_0dsmax


               r0_em=wr_em(n0)
               wr0_em(ifreq)=r0_em  
               z0_em=wz_em(n0)
               wz0_em(ifreq)=z0_em  
               phi=0.d0
               bmod=b(z0_em,r0_em,phi)
               wrho0_em(ifreq)=rho
               wtemp_pl_fr(ifreq)=tempe(z0_em,r0_em,phi,1)!KeV
c               write(*,*)'genray.f ifreq,wr0_em(ifreq),wz0_em(ifreq)'
c     +         ,ifreq,wr0_em(ifreq),wz0_em(ifreq),
c     +         'wtemp_pl_fr(ifreq)',wtemp_pl_fr(ifreq)
            
c               write(*,*)'genray.f before r_2nd_harm'
               

c--------------------------------------------------------
c              calculate the major radius at EC second harmonic point
c              at z=0 
c              (to use drawemfr.in file i_r_2nd_harm=1)
c              (to use drawemf1.in file i_r_2nd_harm=0)
c-------------------------------------------------------
               if(i_r_2nd_harm.eq.1) then
                  wr_2nd_harm(ifreq)=r_2nd_harm(1)
                  write(*,*)'genray.f ifreq,wr_2nd_harm(ifreq)',
     &            ifreq,wr_2nd_harm(ifreq)
               endif               

c-------------------------------------------------------
c              calculate the bulk electron temperuture at 
c              EC second harmonic point z=0
c-------------------------------------------------------
cSm050927
               if (wr_2nd_harm(ifreq).gt.rmax) then
                 wtemp_2nd_harm(ifreq)=0.d0
               else
                 psi_loc=fpsi(wr_2nd_harm(ifreq),z) 
                 rho_loc=rhopsi(psi_loc)
                 wtemp_2nd_harm(ifreq)=temperho(rho_loc,1)
               endif

               write(*,*)'genray.f after wr_2nd_harm(ifreq)',
     +         wr_2nd_harm(ifreq)

               call cpu_time(time_emission_2)     
               write(*,*)'time_emission',time_emission_2-time_emission_1     
            endif !emission    
            
 24         continue !it was iraystop=1 bad initial condition for the ray
        
CMPIINSERTPOSITION ENDEMISSION
            write(*,*)'genray.f i_bad_initial_conditions',
     &                         i_bad_initial_conditions

            if(i_bad_initial_conditions.eq.0) then
c--------------------------------------------------------------------
c             calculates total power launched along rays with 
c             good initial conditions
c--------------------------------------------------------------------
              power_launched=power_launched+powini
c---------------------------------------------------------------------
c             writing ray data to mnemonic.txt and/or 
c             saving data for mnemonic.nc
c-------------------------------------------------------------------  
              write(*,*)'in genray.f before write3d nrayl=',nrayl
	      call write3d
              write(*,*)'in genray.f after write3d nrayl=',nrayl         
              if (i_emission.eq.1) then
                 if (nfreq.gt.1) then
c---------------------------------------------------------------------
c                   calculate the emission temperature KEV for
c                   multi-frequency case
c---------------------------------------------------------------------
                    pi=4.d0*datan(1.d0)
                    clight=2.9979d10
                    wtemp_rad_fr(ifreq)=2.d0*pi*clight**2*
     +                wi_0(iray,ifreq)/(wfreq(ifreq)*1.d9)**2/1.6022d-9

                    wtemp_rad_fr_wall(ifreq)=2.d0*pi*clight**2*
     +               wi_0t(iray,ifreq)/(wfreq(ifreq)*1.d9)**2/1.6022d-9
                  
c                   write(*,*)'genray.f iray,ifreq,wfreq(ifreq)',
c     +             iray,ifreq,wfreq(ifreq)
c                   write(*,*)' wi_0(iray,ifreq)',wi_0(iray,ifreq)
                    write(*,*)'wtemp_rad_fr(ifreq)',wtemp_rad_fr(ifreq)
                    write(*,*)'wtemp_rad_fr_wall(ifreq)',
     &                        wtemp_rad_fr_wall(ifreq)
                    write(*,*)'wtemp_pl_fr(ifreq)',wtemp_pl_fr(ifreq)
                 endif ! (nfreq.gt.1))
c-----------------------------------------------------------------------
c                put emission data in writencdf.i
c-----------------------------------------------------------------------
                 write(*,*)'genray.f before put_emission_in_writencdf_i'
                 call put_emission_in_writencdf_i(ifreq,iray) 
                 write(*,*)'genray.f after put_emission_in_writencdf_i'
              endif ! (i_emission.eq.1)
c------------------------------------------------------------
              call cpu_time(time_loop_ifreq_2)
              time_loop_ifreq=time_loop_ifreq_2-time_loop_ifreq_1
              write(*,*)'time_loop_ifreq',time_loop_ifreq
          
c------------------------------------------------------------------
c             calculate the spectrum of the emission flux
c-----------------------------------------------------------------
              write(*,*)'genray.f i_bad_initial_conditions',
     &                            i_bad_initial_conditions

              write(*,*)'genray.f before emission_spectrum'
              write(*,*)'ifreq,iray,nrayelt_o_cutoff_emis',
     &                       ifreq,iray,nrayelt_o_cutoff_emis
           
              call emission_spectrum(ifreq,iray,
     &             nrayelt_o_cutoff_emis)
              write(*,*)'genray.f after emission_spectrum'

            else
cSAP091016
c              nrayelt_emis_nc(ifreq)=0
c-------------calculate the total number of rays having 
c             i_bad initial conditions=1
              i_total_bad_initial_conditions= 
     &         i_total_bad_initial_conditions+1 
            endif !i_bad_initial_conditions 
c--------------------------------------------------------------

 25         continue! ifreq       
 26         continue                   
          
c           do ifreq=1,nfreq
c            write(*,*)'iray,ifreq',iray,ifreq
c            write(*,*)'wi_0(iray,ifreq)',wi_0(iray,ifreq)
c            write(*,*)'wi_0_nc(iray,ifreq)',wi_0_nc(iray,ifreq)
c           enddo         
CMPIINSERTPOSITION SAVEDATA
c-------------------------------------------------------------
c           if ((i_emission.eq.1).and.(nfreq.gt.1)) then
c--------------calculate the emission temperature KEV for multi-frequency case
c               pi=4.d0*datan(1.d0)
c               clight=2.9979d10
c               do ifreq=1,nfreq                  
c                  wtemp_rad_fr(ifreq)=2.d0*pi*clight**2*
c     +            wi_0(iray,ifreq)/(wfreq(ifreq)*1.d9)**2/1.6022d-9

c                  wtemp_rad_fr_wall(ifreq)=2.d0*pi*clight**2*
c     +            wi_0t(iray,ifreq)/(wfreq(ifreq)*1.d9)**2/1.6022d-9
                  
c                  write(*,*)'genray.f iray,ifreq,wfreq(ifreq)',
c     +            iray,ifreq,wfreq(ifreq)
c                  write(*,*)' wi_0(iray,ifreq)',wi_0(iray,ifreq)
c                  write(*,*)'wtemp_rad_fr(ifreq)',wtemp_rad_fr(ifreq)
c                  write(*,*)'wtemp_rad_fr_wall(ifreq)',
c     &                       wtemp_rad_fr_wall(ifreq)
c                  write(*,*)'wtemp_pl_fr(ifreq)',wtemp_pl_fr(ifreq)
c               enddo
c           endif
            write(*,*)'genray.f loop 20 before mk_gremfr iray',iray
            write(*,*)'genray.f before mk_gremfr freqncy0',freqncy0
cSAPO090830
c            call mk_gremfr(iray,nray)
            if (i_emission.ne.0) call mk_gremfr(iray,nray)
            write(*,*)'genray.f loop 20 after mk_grem'

 20         continue ! iray=1,nray 
      
      if ((i_emission.eq.1).and.(nfreq.gt.1))then
c-----------------------------------------------------------------------------
c     calculate the averaged temperature over all rays for multi-frequency case
c-----------------------------------------------------------------------------
        do ifreq=1,nfreq
cSAP090710
c           waveraged_temp_rad_fr_nc(nfreqa)=0.d0
           call bcast(waveraged_temp_rad_fr_nc,0.d0,
     &              SIZE(waveraged_temp_rad_fr_nc)) 

           sum_emission=0.d0
           sum_emission_wall=0.d0 

           do iray=1,nray
             sum_emission=sum_emission+wi_0_nc(iray,ifreq)
             sum_emission_wall=sum_emission_wall+wi_0_nc(iray,ifreq)  
c             write(*,*)'ifreq,iray,sum_emission,sum_emission_wall',
c     &                  ifreq,iray,sum_emission,sum_emission_wall
  
           enddo

          if (sum_emission.le.1.d-100) then
             waveraged_temp_rad_fr_nc(ifreq)=0.d0
             waveraged_temp_rad_fr_wall_nc(ifreq)=0.d0
          else
             do iray=1,nray
                
                waveraged_temp_rad_fr_nc(ifreq)=
     &            waveraged_temp_rad_fr_nc(ifreq)+
     &            wtemp_rad_fr_nc(iray,ifreq)*
     &            wi_0_nc(iray,ifreq)/sum_emission
              
                waveraged_temp_rad_fr_wall_nc(ifreq)=
     &            waveraged_temp_rad_fr_wall_nc(ifreq)+
     &            wtemp_rad_fr_wall_nc(iray,ifreq)*
     &            wi_0_nc(iray,ifreq)/sum_emission_wall      
               
             enddo  
          endif
    
        enddo

      endif ! (i_emission.eq.1).and.(nfreq.gt.1)
   
CMPIINSERTPOSITION JUSTAFTERTHELOOP

      write(*,*)'genray after 20 continue'
c      call read_emfr_bin(iray)
c     end iray loop

c-----close PGgplot 
      call plotend

      if(rayop.eq."text" .or. rayop.eq."both") then
c--------close file for 3d FP code
         close(i_)
      endif

      write(*,*)'genray: powtot_e,powtot_i',powtot_e,powtot_i
      if(rayop.eq."netcdf" .or. rayop.eq."both") then

c         write(*,*)'read before wrtnetcdf(1)'
c          read(*,*)
 110     continue

         call wrtnetcdf(1)
         write(*,*)'genray.f after  wrtnetcdf(1)'
c--------it will write data to nc file in one ray point
c        at number of point is=80 and
c        at number of ray iray=1

         write(*,*)'before wrtnetcdf`_one_ray_point(1,80,1)'

         call wrtnetcdf_one_ray_point(1,80,1)
    
         call wrtnetcdf(0)              
         write(*,*)'genray.f after  wrtnetcdf(0)' 

c--------it will write data to nc file in one ray point
c        at number of point is=80 and
c        at number of ray iray=1
         write(*,*)'before wrtnetcdf_one_ray_point(0,80,1)'

         call wrtnetcdf_one_ray_point(0,80,1)

         write(*,*)'genray.f afterwrtnetcdf_one_ray_point(0,80,1)'


c-------------------------------------------------------------
c        writesw peqdsk and r,z eqdsk mesh to existing 
c           netcdf file
c-------------------------------------------------------------
         call netcdf_eqdsk_data(filenc)
c-------------------------------------------------------------
         if ((n_wall.ne.0).or.(max_limiters.ne.0)) then
c-----------writes wall and limiter coordinates to existing 
c           netcdf file
            write(*,*)'genray.f before netcdf_wall_lim_data filenc',
     &                 filenc 
             call wrtnetcdf_wall_limiter_data(filenc)

         endif
      endif
      write(*,*)'genray: powtot_e,powtot_i',powtot_e,powtot_i
  

 
      if ((istart.eq.2).or.(istart.eq.3)) then
c--------write ray starting coordinates in filenc.nc file
         write(*,*)'genray.f before wrtnetcdf_grill_launch filenc',
     &   filenc
         call wrtnetcdf_grill_launch(filenc)
      endif

      if (istart.eq.1) then
c--------write ray starting coordinates in filenc.nc file
         write(*,*)'genray.f before wrtnetcdf_EC_launch filenc',
     &   filenc

c         write(*,*)'read before wrtnetcdf_EC_launch'
c         read(*,*)

         call wrtnetcdf_EC_launch(filenc)

c         write(*,*)'read after wrtnetcdf_EC_launch'
c         read(*,*)

      endif

      close(i1_)

cSAP091030
      if(ionetwo.eq.1) then
c--------------------------------------------------------------------
c        calculation power and current density profiles at radius rho
c---------------------------------------------------------------------
         write(*,*)'genray.f before dnonetwo ionetwo',ionetwo
         call dnonetwo         
         write(*,*)'genray.f after dnonetwo ionetwo',ionetwo
      endif
 
cSAP090306
c 1010 format('total power absorbed at reflections(erg/sec)=',1pe14.6)
c      write(*,1010) w_tot_pow_absorb_at_refl
 1010 format('total power absorbed at reflections(watt)=',1pe14.6)
      write(*,1010) w_tot_pow_absorb_at_refl*1.d-7


      write(*,*)'genray.f, partner=',partner
      if (partner.eq.'genray_profs_in.txt' 
     &    .or. partner.eq.'genray_profs_in.nc' 
     &    .or. partner.eq.'genray_profs_out.nc') then
c-----------------------------------------------------------------
c       write power density and current density profiles
c       at ONETWO small radial grid in the file: genray_profs_out
c-----------------------------------------------------------------
         write(*,*)'genray.f before write_transport_prof'
         igenray=19         
c         call write_transport_prof(NR,nbulk,igenray,indexrho,
c     &   powden_e,powden_s,powden_i,currden,powtot_e,powtot_i,
c     &   powtot_s,powtott,currtot) 
c-------- Here: s_cur_den_onetwo is ONETWO RF current density <j_par*B>/B_0
c               currtot is the total toroidal RF current                
         call write_transport_prof(NR,nbulk,igenray,indexrho,
     &   powden_e,powden_s,powden_i,s_cur_den_onetwo,powtot_e,powtot_i,
     &   powtot_s,powtott,currtot) 
      endif
c--------------------------------------------------------------------
c     Output power and current density profiles at radius rho
c--------------------------------------------------------------------

      if(ionetwo.eq.1) then
         write(*,*)'genray.f before mk_gronetwo ionetwo',ionetwo
         call mk_gronetwo
         call mk_gronetwo_1
      endif

      write(*,*)'genray.f before wrtnetcdf_prof 1'
      call wrtnetcdf_prof(filenc,1)
      write(*,*)'genray.f before wrtnetcdf_prof 0'
      call wrtnetcdf_prof(filenc,0)
      write(*,*)'genray.f after wrtnetcdf_prof 0'

c--------------------------------------------------------------------
c     creates some data for drawing
c--------------------------------------------------------------------

      write(*,*)'genray before mkgrtool' 

      if(itools.eq.1) call mkgrtool

      write(*,*)'genray after mkgrtool' 
c--------------------------------------------------------------------
c     write dielectric tensor to mnemonic.nc file
c--------------------------------------------------------------------
      if (dielectric_op.eq.'enabled') then

c         write(*,*)'read before wrtnetcdf_eps'
c         read(*,*)

         call  wrtnetcdf_eps(filenc)

c         write(*,*)'read after wrtnetcdf_eps'
c         read(*,*)

      endif
c--------------------------------------------------------------------
c     write emission data to mnemonic.nc file
c--------------------------------------------------------------------
      if (i_emission.eq.1) then
        write(*,*)'genray.f before wrtnetcdf_emission filenc=',
     &      filenc

c        write(*,*)'genray.f 3'
c        do iray=1,nray
c         do ifreq=1,nfreq
c            write(*,*)'iray,ifreq',iray,ifreq
c            write(*,*)'wi_0(iray,ifreq)',wi_0(iray,ifreq)
c            write(*,*)'wi_0_nc(iray,ifreq)',wi_0_nc(iray,ifreq)
c         enddo      
c        enddo

c        write(*,*)'read before wrtnetcdf_emission'
c        read(*,*)

        call wrtnetcdf_emission(filenc,nray)

        write(*,*)'genray.f after wrtnetcdf_emission filenc=',
     &      filenc

        call wrtnetcdf_emission_spectrum(filenc)
        write(*,*)'genray.f after wrtnetcdf_emission_spectrum filenc='
     &     ,filenc
        call read_nc(filenc)
        write(*,*)'genray.f after read_nc'
      endif
c--------------------------------------------------------------------
      write(*,*)'nrayelt_o_cutoff', nrayelt_o_cutoff
c                             
c  
      call cpu_time(time_genray_2)
      write(*,1003) time_genray_2-time_genray_1
 1003 format('genray.f runtime [sec] ',1pd14.5)
      write(*,1004)
 1004 format('genray.f: Normal end of program')

CMPIINSERTPOSITION ENDMPI

      stop 
      end

CMPIINSERTPOSITION SUBS

c *****************************************************************
c ********* Tokamak data output to con1 ***************************
c *****************************************************************
      subroutine output_con1
      implicit double precision (a-h,o-z)
      include 'param.i'
      include 'one.i'
      include 'three.i'
      open(30,file='con1')
      write(30,90) nxeqd,nyeqd
90    format(8x,' the data of input file',/,
     . 2x,'the numbers of points in the r direction:',i3,/,
     . 2x,'the numbers of points in the z direction:',i3)
      write(30,11) xdimeqd*r0x,ydimeqd*r0x,reqd*r0x,redeqd*r0x,
     1             ymideqd*r0x
11    format(2x,'the full-width of rectangle: dx=',f12.6,' m',/,
     .  30x,' dy=',f12.6,' m',/,
     .  2x,'the major radius of the torus:',f12.6,' m',/,
     .  2x,'the major radius of the inner edge',/,
     .  2x,'of rectangular grid:',f12.6,' m',/,
     .  2x,'the vertical shift up-down symmetry plane:',f12.6,' m')
      write(30,12) xma*r0x,yma*r0x,psimag*b0*r0x**2,
     1             psilim*b0*r0x**2,beqd*b0
12    format(2x,'the major radius of magnetic axis:',f12.6,' m',/,
     .  2x,'the vertical height of magnetic axis:',f12.6,' m',/,
     .  2x,'the poloidal flux function values',/,
     .  2x,'at the magnetic axis:',f12.6,/,
     .  2x,'and the last closed flux surface:',f12.6,/,
     .  2x,'the toroidal magnetic field',/,
     .  2x,'at major radius of the torus:',f12.6,' t')
      write(30,13) toteqd
13    format(2x,'the toroidal curent:',e17.8,' a')
      close(30)

      return
      end


      subroutine onetwoini
c--------------------------------------------
c     set zero to arrays power and current
c     for subroutine p_c_prof
c------------------------------------------
CSAP090630
      implicit none
c      implicit double precision (a-h,o-z)
      include 'param.i'
      include 'one.i'
      include 'onetwo.i'

c-----locals
      integer i,kk

      write(*,*)'onetwoini NR,NRA', NR,NRA


cSAP090625
c      do i=1,NRA
      do i=1,NR
         spower(i)=0.0d0
         spower_e(i)=0.0d0
         spower_i(i)=0.0d0
         spower_cl(i)=0.0d0
         scurrent(i)=0.0d0       
      enddo
cSAP090625
c      do i=1,NRA-1
      do i=1,NR-1
         s_cur_den_parallel(i)=0.d0
      enddo
cSAP090625
c      do kk=1,nbulka
c         do i=1,NRA-1
       do kk=1,nbulk
         do i=1,NR-1
            spower_s(i,kk)=0.0d0
         enddo
      enddo


      return
      end
c*************************contourb*************************************
c  It calculates contours coordinates for the open contours R=R(z):   *
c          modb(r,z)=const and y_(r,z,phi,2)=1./n, n=1,2,...          *      			      *
c          arrays ry(j,i) zpsi(i)  				      *
c          j=1,100 npsi(number of countours n=1,100)        	      *
c          i=0,nz (parameter nz is a number of points in z direction) *
c---------------------------------------------------------------------
c  input data are in common one.i,five.i                	      *
c---------------------------------------------------------------------*
c  Output: arrays AR,AZ, zpsi,rpsi into common block 'gr              *
c          (file gr.cb)                                               *
c**********************************************************************

      subroutine contourb
      implicit double precision (a-h,o-z)
      include 'param.i'
      include 'one.i'
      include 'three.i'
      include 'five.i'
      parameter (nz=20)
      dimension	 zy(nz),ry(100,nz)
      double precision ias1r,b
      external b
      character jy*2
      character outdaty*20,chj*8

      phi=0.d0
      btotl=b(zrmin,rmin,phi)
      bmod=btotl
      yl_i=y(zrmin,rmin,phi,2)
      btotr=b(zrmax,rmax,phi)
      bmod=btotr
      yr_i=y(zrman,rmax,phi,2)
c      write(*,*)'in contourb yl_i yr_i',yl_i,yr_i
      nll=int(1./yl_i)
      nlr=int(1./yl_i)+1
      nrl=int(1./yr_i)
      nrr=int(1./yr_i)+1
c      write(*,*)'in contourb nll,nlr,nrl,nrr',nll,nlr,nrl,nrr
      hz=(zmax-zmin)/dfloat(nz)
      epsy=1d-5 ! accuracy 
      phi=0.d0
      do i=0,nz
        z=zmin+i*hz
	zy(i)=z
	do j=nlr,nrl
c          determination of ry(j,i) where
c          y(z,ry,phi,2)=1/j (using the binary method)
	   tl=rmin
	   tr=rmax
	   c=1.d0/float(j)
           do while ((tr-tl).gt.epsy)
             t=tl+(tr-tl)*0.5d0
             r=t
	     bmod=b(z,r,phi)
             y1=y(z,r,phi,2)-c
             rtr=tr
	     bmod=b(z,rtr,phi)
             y2=y(z,rtr,phi,2)-c
             if ((y1*y2).gt.0) then
               tr=t
             else
               tl=t
             end if
           end do
c          -----------------------------------------------
c          end of the binary methode
c          -----------------------------------------------
c	   write(*,*)'j,i',j,i
c	   write(*,*)'tr-tl,t',tr-tl,t
c	   bmod=b(z,r,phi)
c	   write(*,*)'y1,y(z,r,phi,2),c',y1,y(z,r,phi,2),c
c	   write(*,*)'r,z',r,z
           ry(j,i)=r
         enddo !j	
      enddo !i	
c         CALL ASSIGN("assign -F f77 -N ieee u:82",ier)
      write(*,*)'contours 1/Y_i=n will be ploted for n=',nlr,'...',nrl 
 10   format(3(1pe11.3))
 11   format(2(1pe11.3))
 12   format(34(1pe11.3))
      do j=nlr,nrl
        call charnumb(j,chj)
        outdaty=chj//'.dat'
c	write(*,*)outdaty
	open(j,file=outdaty)
        do i=0,nz
	  bmod=b(zy(i),ry(j,i),phi)
     
c---------------- idx derivativs order 0.ge.idx.le.3---------------
          idx=0
          ipx=ip
          ipx4=ip+4
          rrr=ry(j,i)
          zzrp=ias1r(trlimp,ipx,ipx4,cxlimp,idx,rrr)
          zp=zzrp
          ipx=im
          ipx4=im+4
          zzrm=ias1r(trlimm,ipx,ipx4,cxlimm,idx,rrr)
          zm=zzrm
          if ((zy(i).le.zp).and.(zy(i).ge.zm)) then
c           write(*,*)'in write r,zm,z,zp',rrr,zm,zy(i),zp
c            write(1,10)ry(j,i),zy(i),dfloat(j)
c            write(2,11)ry(j,i),zy(i)
            write(j,11)ry(j,i)*100.d0,zy(i)*100.d0 ! *100 to get cm
          endif
	enddo
	close(j)
      enddo
      write(*,*)'end of contourb'
c      close(1)
c      close(2)
c      close(3)
      return
      end
***********charnumb*******************************************
*     The transformation of the integer j to character chj
*     It is assumed that the number of the decimal numbers in j<=8
******************************************************
c     input : j   is integer 
c     ATTENTION: the number of decimal positions in j should be<=8
c     output: chj is character*8 
c-------------------------------------------------------------
      subroutine charnumb(j,chj)
      integer nj
      parameter (nj=8) ! the max number of the decimal numbers in j 
      character chj*8
      character ikch
      dimension ikch(nj)
      ich0=ichar('0')

      k=1
      jk=j/10

      do while(jk.ne.0) 
         k=k+1
	 jk=jk/10
      enddo	 
c      write(*,*)'k is the number of the decimal nimbers in j',k
      if(k.gt.nj)then
        write(*,*)'in charnumb k>nj'
	stop
      endif
      do i=1,nj
         ikch(i)='0'
      enddo

      jk=j
      do i=1,k
         jkn=jk/10
	 ik=jk-jkn*10
	 jk=jkn
c	 ikch(k) is the decimal number in the j in the k position  
c        The position numeration is from the right side
	 ikch(i)=char(ik+ich0)
      enddo
      chj=ikch(8)//ikch(7)//ikch(6)//ikch(5)//ikch(4)//ikch(3)//
     +ikch(2)//ikch(1)
c      write(*,*)'in charnumb chj=',chj
      return
      end

c*************************contrb1 *************************************
c  It calculates contours coordinates for the open contours R=R(z):   *
c          modb(r,z)=const and y_(r,z,phi,2)=1./n, n=1,2,...          *      			      *
c          arrays ry(j,i) zpsi(i)  				      *
c          j=1,100 npsi(number of countours n=1,100)        	      *
c          i=0,20 ( a number of points in z direction)                *
c---------------------------------------------------------------------
c  input data are in common one.i,five.i                	      *
c---------------------------------------------------------------------*
c* Output: arrays (r,z,) for the given values 1/Y_i=n to               *
c  files: outputy=n.dat         				      *
c**********************************************************************

      subroutine contrb1
      implicit double precision (a-h,o-z)
      include 'param.i'
      include 'one.i'
      include 'three.i'
      include 'five.i'
      include 'gr.i'
      include 'write.i'
      dimension	 zy(20),ry(100,20)
      double precision ias1r
      character chj*8
      character outdaty*20
      iw_j=iwj
c      write(*,*)'in contrb1 iw_j',iw_j
      phi=0.d0

      nnr=40
      nz=40

      hr=xdimeqd/(nnr-1.d0)
      hz=ydimeqd/(nz-1.d0)
      bmin=b(zrmin,rmin,phi)
c      write(*,*)'0 bmin',bmin
     
      open(5,file='wdwci.doc')
      do i=1,nnr+1
	r=4.d0+0.05d0*(dfloat(i)-1.d0)
        do j=1,nz
	  z=-2.d0+0.1d0*(dfloat(j)-1.d0)
          bmod=b(z,r,phi)
	  dyci=1.d0/y(z,r,phi,iw_j)
	  write(5,10)r,z,dyci
	enddo
      enddo
      close(5)
     
      nnr=40
      nz=30
      nz=71
      hr=xdimeqd/(nnr-1.d0)
      hz=ydimeqd/(nz-1.d0)
      hz=14.d0/(nz-1.d0)
c      hr=0.05d0
c      nz=0.1d0
      open(4,file='btot.doc')
      do i=1,nnr
	r=redeqd +hr*(i-1.d0)
c	r=4.d0+hr*(i-1.d0)
        do j=1,nz
          z=ymideqd+hz*(j-1)-ydimeqd*0.5
          z=-7.0d0+hz*(j-1)
c	  write(*,*)'in contrb1 i,z,j,r',i,z,j,r
          btot=b(z,r,phi)
c	  write(*,*)'in contrb1 i,z,j,r, btot',i,z,j,r,btot
	  write(4,10)r,z,btot
        enddo
      enddo
      close(4)

      btotl=b(zrmin,rmin,phi)
      bmod=btotl
      yl_i=y(zrmin,rmin,phi,iw_j)
      btotr=b(zrmax,rmax,phi)
      bmod=btotr
      yr_i=y(zrman,rmax,phi,iw_j)
      write(*,*)'in contourb btotl btotr',btotl,btotr
      write(*,*)'in contourb yl_i yr_i',yl_i,yr_i
      nll=int(1./yl_i)
      nlr=int(1./yl_i)+1
      nrl=int(1./yr_i)
      nrr=int(1./yr_i)+1
      write(*,*)'in contrb1 nll,nlr,nrl,nrr',nll,nlr,nrl,nrr
      nz=20
      hz=(zmax-zmin)/dfloat(nz)
      epsy=1d-5 ! accuracy 
      phi=0.d0
      do i=1,nz
        z=zmin+i*hz
	zy(i)=z
	do j=nlr,nrl
c          determination of ry(j,i) where
c          y(z,ry,phi,iw_j)=1/j (using the binary method)
	   tl=rmin
	   tr=rmax
	   c=1.d0/float(j)
           do while ((tr-tl).gt.epsy)
             t=tl+(tr-tl)*0.5d0
             r=t
	     bmod=b(z,r,phi)
             y1=y(z,r,phi,iw_j)-c
             rtr=tr
	     bmod=b(z,rtr,phi)
             y2=y(z,rtr,phi,iw_j)-c
             if ((y1*y2).gt.0) then
               tr=t
             else
               tl=t
             end if
           end do
c          -----------------------------------------------
c          end of the binary method
c          -----------------------------------------------

           ry(j,i)=r
         enddo !j	
      enddo !i	
c         CALL ASSIGN("assign -F f77 -N ieee u:84",ier)
      write(*,*)'contours 1/Y_i=n will be plotted for n=',nlr,'...',nrl 
 10   format(3(1pe11.3))
 11   format(2(1pe11.3))
 12   format(34(1pe11.3))
      do j=nlr,nrl
        call charnumb(j,chj)
        outdaty=chj//'.dat'
	write(*,*)outdaty
	open(1,file=outdaty)
        do i=1,20
	  bmod=b(zy(i),ry(j,i),phi)
c	  write(*,*)'j,y=1/j,y(zy(i),ry(j,i),phi,iw_j),zy(i),ry(j,i)',
c     6	  j,1.d0/dfloat(j),y(zy(i),ry(j,i),phi,iw_j),zy(i),ry(j,i)
     
c---------------- idx derivativs order 0.ge.idx.le.3---------------
          idx=0
          ipx=ip
          ipx4=ip+4
          rrr=ry(j,i)
          zzrp=ias1r(trlimp,ipx,ipx4,cxlimp,idx,rrr)
          zp=zzrp
          ipx=im
          ipx4=im+4
          zzrm=ias1r(trlimm,ipx,ipx4,cxlimm,idx,rrr)
          zm=zzrm
c         write(*,*)'in bound r,zm,z,zp',rrr,zm,zy(i),zp
          if ((zy(i).le.zp).and.(zy(i).ge.zm)) then
c           write(*,*)'in write r,zm,z,zp',rrr,zm,zy(i),zp
c           write(*,*)'ry(j,i)*100,zy(i)*100)'
c           write(*,*)ry(j,i)*100,zy(i)*100

c            write(1,10)ry(j,i),zy(i),dfloat(j)
c            write(2,11)ry(j,i),zy(i)
            write(1,11)ry(j,i)*100.d0,zy(i)*100.d0 ! *100 to get cm
         WRITE(84) REAL(ry(j,i)*100),REAL(zy(i)*100),
     1   REAL(XT(3,NP+1)),REAL(YT(3,NP+1)),
     2   REAL(ws(nrayelt)),REAL(delpwr(nrayelt)),REAL(rez(nrayelt)),
     3   REAL(spsi(nrayelt)),REAL(wnpar(nrayelt)),REAL(wnper(nrayelt)),
     4   REAL(salphal(nrayelt))
         WRITE(83,5)ry(j,i)*100,zy(i)*100,
     1   XT(3,NP+1),YT(3,NP+1),
     2   ws(nrayelt),delpwr(nrayelt),rez(nrayelt),
     3   spsi(nrayelt),wnpar(nrayelt),wnper(nrayelt),
     4   salphal(nrayelt)
          endif
	enddo
        WRITE(84)
        WRITE(83,2)
 2    format(/)
	close(1)
      enddo
 5    format(11(1pe10.3))
      return
      end





c*************************contrb2 *************************************
c  It calculates contours coordinastes for contours:		      *
c          modb(r,z)=const and y_(r,z,phi,2)=1./n, n=1,2,...          *
c          for the case then the closed contours exist.                *
c          arrays ry(j,i) thetac(i)  				      *
c          j=1,100 npsi(number of countours n=1,100)        	      *
c          i=0,nthetac (number of points in thetac direction)      	      *
c---------------------------------------------------------------------
c  input data are in common one.i,five.i                	      *
c---------------------------------------------------------------------*
c* Output: arrays (r,z,) for the give values 1/Y_i=n to               *
c  files: outputy=n.dat         				      *
c**********************************************************************

      subroutine contrb2
      implicit double precision (a-h,o-z)
      include 'param.i'
      include 'one.i'
      include 'three.i'
      include 'five.i'
      include 'gr.i'
      include 'write.i'
      parameter (nthetac=20, nthetac1=nthetac+1)
      dimension	 thetac(nthetac),zy(100,nthetac1),ry(100,nthetac1)
      double precision ias1r
      character outdaty*20,chj*8
      iw_j=iwj
      phi=0.d0
c------------------------------------------------------
c     creation of the btot.doc file with the coordinates (r,z) and
c     the values of mod(b(r,z))
c     calculation the coordinates (rbmin zbmin) of the point
c     inside the plasma where btot(rbmin,zbmin)=bmin
c------------------------------------------------------
c      write(*,*)'in contrb2 before nz=40'
      nnr=40
      nz=40
      hr=xdimeqd/(nnr-1.d0)
      hz=ydimeqd/(nz-1.d0)
      bmin=b(zrmin,rmin,phi)
c      write(*,*)'0 bmin',bmin
      open(4,file='btot.doc')
      open(5,file='wdwci.doc')
      do i=1,41
	r=4.d0+0.05d0*(dfloat(i)-1.d0)
        do j=1,40
	  z=-2.d0+0.1d0*(dfloat(j)-1.d0)
          bmod=b(z,r,phi)
	  dyci=1.d0/y(z,r,phi,iw_j)
	  write(5,10)r,z,dyci
	enddo
      enddo
      close(5)
      close(4)
c      stop
      do i=1,nnr
	r=redeqd +hr*(i-1.d0)
        do j=1,nz
          z=ymideqd+hz*(j-1)-ydimeqd*0.5
          btot=b(z,r,phi)
cc          bmod=b(z,r,phi)
cc	  dyci=1.d0/y(z,r,phi,iw_j)
c	  write(*,*)'in contrb2 i,z,j,r,btot,bmin',i,z,j,r,btot	,bmin
c---------------- idx derivativs order 0.ge.idx.le.3---------------
          idx=0
          ipx=ip
          ipx4=ip+4
          rrr=r
          zzrp=ias1r(trlimp,ipx,ipx4,cxlimp,idx,rrr)
          zp=zzrp
          ipx=im
          ipx4=im+4
          zzrm=ias1r(trlimm,ipx,ipx4,cxlimm,idx,rrr)
          zm=zzrm
          if ((z.le.zp).and.(z.ge.zm)) then
	    if(bmin.gt.btot) then
	      bmin=btot
	      rbmin=r
	      zbmin=z
	    endif
	  endif
	  write(4,10)r,z,btot
cc	  write(5,10)r,z,dyci
        enddo
      enddo
      close(4)
c      close(5)
      write(*,*)'in contrb2 bmin, zbmin,rbmin',bmin, zbmin,rbmin
c      stop
      btotmin=b(zbmin,rbmin,phi)
      bmod=btotmin
      ybmin_i=y(zbmin,rbin,phi,iw_j)
c      write(*,*)'in contrb2 ybmin_i',ybmin_i
c------------------------------------------------------
c     determination of yl_i(on the left side of plasma)
c     determination of yr_i(on the right side of plasma)
      btotl=b(zrmin,rmin,phi)
      bmod=btotl
      yl_i=y(zrmin,rmin,phi,iw_j)
      btotr=b(zrmax,rmax,phi)
      bmod=btotr
      yr_i=y(zrman,rmax,phi,iw_j)
c      write(*,*)'in contrb2 btotl btotr',btotl,btotr
c      write(*,*)'in contrb2 yl_i yr_i',yl_i,yr_i
c---------------------------------------------------------
c     determination of the ysep=1/Y_ci on the the last closed contour  
      if(yl_i.gt.yr_i) then
         ysep=yl_i
      else
         ysep=yr_i
      endif
c      write(*,*)'in contrb2 ysep',ysep
      ny_min=int(1.d0/ysep+2.d0)
      ny_max=int(1.d0/ybmin_i)
c      write(*,*)'in contrb2 ny_min,ny_max',ny_min,ny_max
c---------------------------------------------------------
c  Calculations coordinates of contours 1/Yci=n				      *
c          r(n,thetac)   z(n,thetac)     			      
c          arrays ry(j,i) zy(j,i)  				      
c          j=ny_min,ny_max(number of contours )	      
c          i=1,nthetac+1(number of points in the poloidal angle)  
      pi=4.d0*datan(1.d0)
      hteta=2.d0*pi/dble(nthetac)
      epsy=1d-3 ! accuracy 
c------------------------------------------------------
c     
c     2)we will create the limiter points using the close flux
c      surface psi(r,z)=psilim*psifactr, here
c      psifactr is a parameter (it must be .le.1) to avoide the
c      problems with the nonmonotonic psi function near the separatrix.
c      psifactr is given in genray.in file (It is in common/one/)
c     ------------------------------------
c      psilim=psimag+(psilim-psimag)*psifactr
c     
c-------------------------------------------------------
c        ipsi=1 !  to calculate contours
c        ipsi=0 !  to read contours data from file:psi.bin
c       if (ipsi.eq.0) then
c         open(1,file='psi.bin',form='unformatted',status='old')
c         do i=1,npsi
c	  do j=1,nteta1
c             read(1)zpsi(i,j),rpsi(i,j)
c	  end do
c         end do
c	 close(1)
c	 go to 200
c       endif
c------------------------------------------------------------------
      do 100 i=1,nthetac
         theta=hteta*(dble(i)-0.5d0)
         sintet=dsin(theta)
         costet=dcos(theta)
	 tini=0.d0
	 tm=3.5d0
	 htini=tm*0.02d0
         maxiter=10
	 htmin=1.d-3
         do 20 j=ny_max,ny_min,-1
           write(*,*)'genray.f contrb2 number of contour Y=1/n j=',j      
           n0=j 
c------------------------------------------------
c          binary method for solution of equation 1/Y(r(t),z(t))=n0
           call zrcntr2(tini,n0,costet,sintet,tm,htini,
     1     ierr,zt0,rt0,t0,zbmin,rbmin,epsy)
c------------------------------------------------
	   tini=t0
	   if (ierr.eq.1) then
              zy(j,i)=zt0
              ry(j,i)=rt0
              write(*,*)'Yj,Thi,zy(j,i),ry(j,i)',j,i,zy(j,i),ry(j,i)
           else
              write(*,*)'zrcontor gave ierr ',ierr
              write(*,*)'it is impossible to find the 1/y surface '
	      write(*,*)' with n',n0,'j=',j
	      write(*,*)' i=',i,'theta',theta
	      write(*,*)' with n0-1',n0-1
	      write(*,*)' it is possible to change 
     1        ny_min=arpsi(j-1) or reduse the factor
     1        psifactr in the subroutine equilib'
       	      stop
	   endif
20       continue
100   continue

      do 40 j=ny_max,ny_min,-1
           zy(j,nthetac1)=zy(j,1)
           ry(j,nthetac1)=ry(j,1)
40    continue
c----------------------------------------------------------
c     if ipsi=1 then continue,write file y.bin
      open(3,file='y.bin',form='unformatted')
      do i=1,npsi
        do j=1,nthetac1
           write(3)zy(i,j),ry(i,j)
        end do
      end do
      close(3)
c------------------------------------------------------------
c     if ipsi=1 then continue,ipsi=0 then read file psi.bin
200    continue
c-------------------------------------------------------------
 10   format(3(1pe11.3))
 11   format(2(1pe11.3))
 12   format(34(1pe11.3))
      do j=ny_min,ny_max
        call charnumb(j,chj)
        outdaty=chj//'.dat'
c	write(*,*)outdaty
	open(1,file=outdaty)
c	write(j,*)'r ',j
c	goto 17 !!!!
        do i=1,nthetac1
	  bmod=b(zy(j,i),ry(j,i),phi)
	  write(*,*)'j,y=1/j,y(zy(i),ry(j,i),phi,iw_j),zy(j,i),ry(j,i)',
     6	  j,1.d0/dfloat(j),y(zy(j,i),ry(j,i),phi,iw_j),zy(j,i),ry(j,i)
     
          WRITE(84) REAL(ry(j,i)*100.),REAL(zy(j,i)*100.),
     1    REAL(XT(3,NP+1)),REAL(YT(3,NP+1)),
     2    REAL(ws(nrayelt)),REAL(delpwr(nrayelt)),REAL(rez(nrayelt)),
     3    REAL(spsi(nrayelt)),REAL(wnpar(nrayelt)),REAL(wnper(nrayelt)),
     4    REAL(salphal(nrayelt))
          WRITE(83,5)ry(j,i)*100,zy(j,i)*100,
     1    XT(3,NP+1),YT(3,NP+1),
     2    ws(nrayelt),delpwr(nrayelt),rez(nrayelt),
     3    spsi(nrayelt),wnpar(nrayelt),wnper(nrayelt),
     4    salphal(nrayelt)
	enddo !i
        WRITE(84)
        WRITE(83,2)
 2    format(/)
 17   continue
      close(1)
      enddo !j
 5    format(11(1pe10.3))
c      write(*,*)'end of contrb2'
c      stop
      return
      end
c*************************zrcntr2*********************************** *
c  It calculates  contours coordinates of the countor point 	       *
c   r(n,teta)   z(n,teta) for the given:			       *
c   1/y_ci(z,r)=n0 and poloidal angle teta0(in radians)                *
c   It using the binary methode                                        *
c---------------------------------------------------------------------
c  input data are in common blocks /three/,/five/,/gr.cb/	       *
c  tini -initial (left) value of the t( ray parameter )		       *
c  n0   -given value of the 1/y_ci       			       *
c  costet0,sintet0 -for the given poloidal angle		       *
c  rbmin major radius of point mod(b)=min (inside the plasma)	       *
c  zbmin Z coordinate of point mod(b)=min (inside the plasma)	       *
c  tm   -maximal value of t (right)				       *
c  htini   ininial step of the t 	 			       *
c  epsy-accuracy of equation solution (=max(abs( 1/y_n-1/y_n+1))
c----------------------------------------------------------------------*
c  Output: ,zt0(n0,teta0),rt0(n0,teta0) and parameter t0               *
c           rt0=xma+t0*costet0 ,  zt0=yma+t0*sintet0		       *
c  ierr -index if the solution was obtained =1	else=0		       *
c**********************************************************************
      subroutine zrcntr2(tini,n0,costet0,sintet0,tm,htini,
     1 ierr,zt0,rt0,t0,zbmin,rbmin,epsy)
      implicit real*8 (a-h,o-z)
      include 'param.i'
      include 'three.i'
      include 'one.i'
      iw_j=iwj
      ierr=1
      ht=htini
      phi=0.d0
      n0=-n0
c      write(*,*)'in zrcntr2 n0,costet0,sintet0',
c     1 n0,costet0,sintet0
c      write(*,*)'tini,tm,htini,epsy'
c     1 ,tini,tm,htini,epsy
      t1=tini
      rt1=rbmin+t1*costet0
      zt1=zbmin+t1*sintet0
      bmod=b(zt1,rt1,phi)
      rn1=-1.d0/y(zt1,rt1,phi,iw_j)
 10   t2=t1+ht
c      write(*,*)'10 t2,t1,rt1,zt1,rn1',t2,t1,rt1,zt1,rn1
      t2=dmin1(t2,tm)
c      write(*,*)'t2',t2
      if((t2.eq.tm.and.t1.eq.tm).or.
     1   (t2.eq.0.d0.and.t1.eq.0.d0)) then
	 ierr=0
c	 write(*,*)'in zrcntr2 error exit ierr',ierr
c         write(*,*)'t2,t1,rt1,zt1,rt2,zt2',t2,t1,rt1,zt1,rt2,zt2
c	 write(*,*)'in zrcntr2 error rn1,rn2,n0',rn1,rn2,n0
c        error exit
         goto30
      endif

      rt2=rbmin+t2*costet0
      zt2=zbmin+t2*sintet0
      bmod=b(zt2,rt2,phi)
      rn2=-1.d0/y(zt2,rt2,phi,iw_j)
      dn=(dfloat(n0)-rn1)*(dfloat(n0)-rn2)
c      write(*,*)'10 t2,rt2,zt2,rn2,dn',t2,rt2,zt2,rn2,dn
      if(dn.le.0.d0)go to 20
      t1=t2
      rn1=rn2
      goto 10
c-----------------------------------------------------------
c     n0 is between rn1 and rn2
c     binary iteration methode
c-----------------------------------------------------------
 20   continue
      tr=t2
      tl=t1
      do while ((tr-tl).gt.epsy)
         t=tl+(tr-tl)*0.5d0
         r=rbmin+t*costet0
         z=zbmin+t*sintet0
         bmod=b(z,r,phi)
         rn1=-1.d0/y(z,r,phi,iw_j)-n0
         rtr=rbmin+tr*costet0
         ztr=zbmin+tr*sintet0
         bmod=b(ztr,rtr,phi)
         rn2=-1.d0/y(ztr,rtr,phi,iw_j)-n0
         if ((rn1*rn2).gt.0) then
            tr=t
         else
            tl=t
         end if
      end do
c     -----------------------------------------------
c          end of the binary methode
c     -----------------------------------------------
      t0=t
      zt0=z
      rt0=r
 30   continue
c      write(*,*)'the end of zrctr2 t0',t0
      return
      end


      subroutine check_param(i_op)
c-----check parameters in param.i
c     i_op=1 check the parameters for eqdsk
c     i_op=2 check the parameters for grill in genray.in

      implicit double precision (a-h,o-z)
      include 'param.i' ! gives the input parameters 
      include 'commons.i'
   
      if ((i_op.lt.1).or.(i_op.gt.2)) then
         write(*,*)'in genray.f,in check_param: wrong value i_op=',i_op
         write(*,*)'It shoud be (i_op.eq.1).or.(i_op.eq.2)'
         write(*,*)'Change i_op in call check_param(i_op)'
         stop
      endif

      if (nraymax.lt.0) then
         write(*,*)'in param.i nraymax <0,it should be >0'
         write(*,*)'Change nraymax in param.i'
         stop
      endif 

      if (i_op.eq.1) then
c--------check the parameters for eqdsk 
              
         if (nveqd.gt.nxeqd) then
            write(*,10110)
            stop
         endif
10110    format("subroutine equilib-nveqd > nxeqd")
cSm030224
         if ((nxeqd.gt.nxeqda).or.(nyeqd.gt.nyeqda)) then
           write(*,1000) nxeqd,nxeqda,nyeqd,nyeqda
 1000 format('in equilib.dat in input',/,
     .'the dimensions of eqdsk (in eqilib.dat) nxeqd or nyeqd',/,
     .'are bigger then the parameters nxeqda or nyeqda in param.i'
     .,/,'nxeqd=',I5,'nxeqda=',I5
     .,/,'nyeqd=',I5,'nyeqda=',I5
     .,/,'Please change nxeqda or nyeqda in param.i')
           stop
         endif

         if (nrya.ne.(max0(nxeqda,nyeqda)+4)) then
            write(*,*)'in param.i nry.ne.(max0(nxeqda,nyeqda)+4)'
            write(*,*)'nrya=',nrya
            write(*,*)'max0(nxeqda,nyeqda)',max0(nxeqda,nyeqda)
            write(*,*)'Change nrya in param.i'
            stop
         endif 
               
cSAP091124      
c         if (nzy.ne.(max0(npsi4,nteta1)+4)) then 
          if (nzy.ne.(max0(npsi,nteta1)+4)) then
cSAP091124
c            write(*,*)'in param.i nzy.ne.max0(npsi4,nteta1)+4'
            write(*,*)'in param.i nzy.ne.max0(npsi,nteta1)+4'
            write(*,*)'nzy= ',nzy
cSAP091124
c            write(*,*)'max0(npsi4,nteta1)',max0(npsi4,nteta1)
            write(*,*)'max0(npsi,nteta1)=4',max0(npsi,nteta1)+4
            write(*,*)'Change nzy in param.i'
            stop
         endif

         goto 10

      endif !i_op=1

      if (i_op.eq.2) then
c--------check the parameters for grill in genray.in
         if (ngrill.gt.ngrilla) then
 20   format('equilib in check_param ngrill>ngrilla',/,
     .'it should be ngrilla.ge,ngrill',/,
     .'ngrilla= ',I4,'ngrill= ',I4,/,
     .'Change ngrilla in param.i or grilld in genray.in')
              write(*,20)ngrilla,ngrill
            stop
         endif
 
         nmax=0
         do i=1,ngrill
           if (nnkpar(i).gt.nmax) nmax=nnkpar(i)
         enddo

         if (nnkprmax.ne.nmax)then
            write(*,30)nnkprmax,nmax
 30          format('genray.f in check_param: it should be',/,
     .      'nnkprmax.ge.max{i=1,ngrill}nnkpar(i)',/,
     .      'nnkprmax= ',I4,'max{i=1,ngrill}nnkpar(i)= ',I4)
            goto 10             
         endif 
          
         nmax=0
         do i=1,ngrill
           if (nthin(i).gt.nmax) nmax=nthin(i)
         enddo

         if (nthinmax.ne.nmax)then
            write(*,40)nthinmax,nmax
 40          format('genray.f in check_param: it should be',/,
     .      'nthinmax.ge.max{i=1,ngrill}nthin(i)',/,
     .      'nthinmax= ',I4,'max{i=1,ngrill}nthin(i)= ',I4)
            goto 10             
         endif 

      endif !i_op=2

 10   continue

      return
      end
              



